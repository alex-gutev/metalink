<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5. Subnodes</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Tridash Tutorials" /><link rel="up" href="index.html" title="Tridash Tutorials" /><link rel="prev" href="ar01s04.html" title="4. Writing your own Functions" /><link rel="next" href="ar01s06.html" title="6. Error Handling with Failure Values" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ar01s04.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s06.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_subnodes"></a>5. Subnodes</h2></div></div></div><p>You’ve already made use of subnodes in the previous tutorials, when
binding to attributes of HTML elements. Now we’ll explores subnodes in
depth.</p><p>A subnode is a node which references a value out of a dictionary of
values stored in a parent node.</p><p><strong>Subnode Syntax. </strong>
</p><pre class="screen">parent.key</pre><p>
</p><p>The left hand side of the subnode <code class="literal">.</code> operator is the parent node
expression and the right hand side is the key identifying the
dictionary entry.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">key</code> is interpreted as a literal symbol rather than a node
identifier.</p></td></tr></table></div><p>A dictionary can be created in a node by binding to a subnode of the
node.</p><p><strong>Example. </strong>
</p><pre class="screen">"John" -&gt; person.name
"Smith" -&gt; person.surname</pre><p>
</p><p>In this example, the value of the node <code class="literal">person</code> is a dictionary with
two entries</p><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">name</code>
</p>
</td><td style="" valign="top">
<p>
Bound to the string constant “John”.
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">surname</code>
</p>
</td><td style="" valign="top">
<p>
Bound to the string constant “Smith”.
</p>
</td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_example_color_object"></a>5.1. Example: Color Object</h3></div></div></div><p>The meter application developed during the previous tutorial was a bit
of mess with the various color components scattered through the code.</p><p>To change the colors you’d first have to change the hue components, in
the following code:</p><pre class="screen">hue &lt;- lerp(120, 0, scale)</pre><p>It isn’t clear what the numbers <code class="literal">120</code> and <code class="literal">0</code> are supposed to be or
which number corresponds to the hue component of which color.</p><p>To change the luminance and saturation components, you’d have to
modify the following:</p><pre class="screen">self.meter.style.backgroundColor &lt;-
    make-hsl(hue, 90, 45)</pre><p>There is also no interpolation of the saturation or luminance
components.</p><p>The code can be made significantly more readable and maintainable by
making use of a dedicated <span class="emphasis"><em>color object</em></span>.</p><p>We’ll create a meta-node <code class="literal">Color</code> which takes the three color
components as arguments and returns a dictionary storing the
components under the entries: <code class="literal">hue</code>, <code class="literal">saturation</code> and <code class="literal">luminance</code>.</p><p>How are we going to return a dictionary from a meta-node? We can
create a dedicated local node, in which the dictionary is created,
such as the following:</p><pre class="screen">Color(hue, saturation, luminance) : {
    hue -&gt; color.hue
    saturation -&gt; color.saturation
    luminance -&gt; color.luminance

    color
}</pre><p>Or we can simply bind to subnodes of the <code class="literal">self</code> node.</p><p><strong>Meta-Node <code class="literal">Color</code>. </strong>
</p><pre class="screen">Color(hue, saturation, luminance) : {
    hue -&gt; self.hue
    saturation -&gt; self.saturation
    luminance -&gt; self.luminance
}</pre><p>
</p><p>The dictionary returned by <code class="literal">Color</code> is how colors will be represented
in our application. Let’s create color objects for the two colors and
bind them to nodes:</p><pre class="screen">color-empty &lt;- Color(120, 90, 45)
color-full  &lt;- Color(0, 90, 45)</pre><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">color-empty</code> and <code class="literal">color-full</code> are examples of constant nodes as
their values are not dependent on other nodes and are thus effectively
constant.</p></td></tr></table></div><p>Rather than interpolating between the components of <code class="literal">color-empty</code> and
<code class="literal">color-full</code> in the global scope, we can create a meta-node that takes
two colors and the alpha coefficient, and returns the interpolated
color.</p><p><strong>Meta-Node <code class="literal">lerp-color</code>. </strong>
</p><pre class="screen">lerp-color(c1, c2, alpha) :
    Color(
        lerp(c1.hue, c2.hue, alpha),
        lerp(c1.saturation, c2.saturation, alpha),
        lerp(c1.luminance, c2.luminance, alpha)
    )</pre><p>
</p><p>The <code class="literal">lerp-color</code> meta-node simply creates a new color, using the
<code class="literal">Color</code> meta-node, with each component interpolated between the two
colors, using <code class="literal">lerp</code>.</p><p>We can use this to easily interpolate between the colors:</p><pre class="screen">color &lt;- lerp-color(color-empty, color-full, scale)</pre><p>To convert the Color object to a CSS color string we have to pass each
component to <code class="literal">make-hsl</code> as an individual argument like so:</p><pre class="screen">make-hsl(color.hue, color.saturation, color.luminance)</pre><p>However, the internal representational details of the color are
leaking into the application logic. All it takes is to accidentally
pass a single component twice or pass the components in the wrong
order and there is a bug.</p><p>To rectify this we can rewrite <code class="literal">make-hsl</code> to take a Color object or we
can bind a subnode of the Color object to the CSS color string.</p><p>Modify <code class="literal">Color</code> to the following:</p><pre class="screen">Color(hue, saturation, luminance) : {
    hue -&gt; self.hue
    saturation -&gt; self.saturation
    luminance -&gt; self.luminance

    make-hsl(hue, saturation, luminance) -&gt; self.hsl-string
}</pre><p>We’ve added a new declaration to <code class="literal">Color</code> which binds the <code class="literal">hsl-string</code>
subnode of <code class="literal">self</code> to the CSS HSL color string, created using
<code class="literal">make-hsl</code>. Since the values of nodes are only evaluated if they are
used, and subnodes are no different, the value of the subnode
<code class="literal">hsl-string</code> will only be computed for the final <code class="literal">color</code> object, not
the <code class="literal">color-empty</code> and <code class="literal">color-full</code> objects.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If you’d like to make the code even neater you can move the
definition of the <code class="literal">make-hsl</code> meta-node inside the <code class="literal">Color</code> meta-node.</p></td></tr></table></div><p>The interpolated color can be bound to the meter’s background color
with the following:</p><pre class="screen"> color.hsl-string -&gt; self.meter.style.backgroundColor</pre><p>We now have a new more readable and maintainable version of the meter
application. Replace the Tridash code tag with the following:</p><pre class="screen">&lt;?
 /import(core)

 # Utilities

 lerp(a, b, alpha) : a + alpha * (b - a)

 clamp(x, min, max) :
     case (
         x &lt; min : min,
         x &gt; max : max,
         x
     )

 make-hsl(h, s, l) :
     format("hsl(%s,%s%%,%s%%)", h, s, l)

 Color(hue, saturation, luminance) : {
     hue -&gt; self.hue
     saturation -&gt; self.saturation
     luminance -&gt; self.luminance

     make-hsl(hue, saturation, luminance) -&gt; self.hsl-string
 }

 lerp-color(c1, c2, alpha) :
     Color(
         lerp(c1.hue, c2.hue, alpha),
         lerp(c1.saturation, c2.saturation, alpha),
         lerp(c1.luminance, c2.luminance, alpha)
     )


 # Application Logic

 color-empty &lt;- Color(120, 90, 45)
 color-full  &lt;- Color(0, 90, 45)

 scale &lt;- clamp(quantity / maximum, 0, 1)

 color &lt;- lerp-color(color-empty, color-full, scale)


 color.hsl-string -&gt; self.meter.style.backgroundColor

 format("%s%%", scale * 100) -&gt; self.meter.style.width
?&gt;</pre><p>Compared to the previous version, this version has a number of benefits:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
It is clearly visible where the two colors are defined, and thus can
be changed easily.
</li><li class="listitem">
The color components are kept in a single place rather than being
scattered throughout the code.
</li><li class="listitem">
All components of the colors are interpolated.
</li></ol></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s04.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s06.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>