<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. Meta-Nodes</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Tridash 0.5 Reference Manual" /><link rel="up" href="index.html" title="Tridash 0.5 Reference Manual" /><link rel="prev" href="ar01s02.html" title="2. Nodes" /><link rel="next" href="ar01s04.html" title="4. Modules" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ar01s02.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s04.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_meta_nodes"></a>3. Meta-Nodes</h2></div></div></div><p><a id="idm371439238976" class="indexterm"></a>
<a id="idm371439237472" class="indexterm"></a>
<a id="idm371439236224" class="indexterm"></a>
<a id="idm371439235232" class="indexterm"></a>
<a id="idm371439233728" class="indexterm"></a>
<a id="idm371439232480" class="indexterm"></a></p><p>A meta-node is a function, of one or more arguments, which returns a
value. Meta-nodes are nodes, themselves, however without a runtime
node object. For the most part you can treat meta-nodes as ordinary
nodes, e.g. you can set meta-node attributes using the same
<code class="literal">:attribute</code> declaration. Referencing the value of a meta-node
references the meta-node function.</p><p>Meta-node identifiers reside in the same namespace as that of ordinary
nodes, that is you cannot have both an ordinary node and meta-node
with identifier <code class="literal">f</code>. If there is a meta-node <code class="literal">f</code>, the node expression
<code class="literal">f</code> references the meta-node function.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Functor nodes with the meta-node as the operator are referred to
as instances of the meta-node.</p></td></tr></table></div><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Meta-nodes are referred to as meta-nodes, since they are nodes
which describe how to compute the value of their instance
nodes. Meta-nodes may also be macro-nodes which are evaluated at
compile-time, with the result being interpreted as Tridash code.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_defining_meta_nodes"></a>3.1. Defining Meta-Nodes</h3></div></div></div><p><a id="idm371439224720" class="indexterm"></a>
<a id="idm371439223472" class="indexterm"></a>
<a id="idm371439222480" class="indexterm"></a>
<a id="idm371439220976" class="indexterm"></a>
<a id="idm371439219728" class="indexterm"></a></p><p>Meta-nodes are defined using the special <code class="literal">:</code> definition operator which
has the following syntax:</p><p><strong>Definition Operator Syntax. </strong>
</p><pre class="screen">name(arg1, arg2, ...) : {
    declarations*
}</pre><p>
</p><p>The meta-node identifier, <code class="literal">name</code>, appears on the left-hand side of the
<code class="literal">:</code> operator followed by the comma-separated list of arguments in
parenthesis. Each item, at position <span class="emphasis"><em>n</em></span>, of the argument list is the
identifier of the local node to which the <span class="emphasis"><em>n</em></span><sup>th</sup> argument is bound.</p><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Identifiers beginning with <code class="literal">:</code> are reserved for special
operators. A meta-node cannot have the same identifier as a special
operator. Currently no warning or compilation error is triggered, if
the identifier begins with <code class="literal">:</code> but is not a special operator, however
that may change in a future release.</p></td></tr></table></div><p>The body consists of a sequence of ordinary node declarations enclosed
in braces <code class="literal">{ ... }</code>. The braces are simply a way of grouping multiple
declarations into a single expression, <span class="emphasis"><em>See <a class="xref" href="ar01s01.html#_node_lists" title="1.3. Node Lists">Section 1.3, “Node Lists”</a></em></span>. If the
body of the meta-node contains just a single expression, the braces
may be omitted.</p><p>The meta-node function returns the value of the last node in the body.</p><p><strong>Example. </strong>
</p><pre class="screen"># Returns 1 + `n`

1+(n) : n + 1</pre><p>
</p><p><strong>Factorial Example. </strong>
</p><pre class="screen"># Computes the factorial of `n`

factorial(n) : {
    case (
         n &gt; 1 : n * factorial(n - 1)
         1
    )
}</pre><p>
</p><p>The following example demonstrates that the body can contain any valid
node declaration:</p><p><strong>Fibonacci Example. </strong>
</p><pre class="screen">fib(n) : {
    fib(n - 1) -&gt; fib1
    fib(n - 2) -&gt; fib2

    case (
        n &lt;= 1 : 1,
        fib1 + fib2
    )
}</pre><p>
</p><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Meta-nodes must be defined before they can occur as
operators in functors.</p></td></tr></table></div><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Meta-node bodies are only processed after all global (or
the scope in which the meta-node declaration occurs) declarations in
the same file have been processed. This allows a meta-node <code class="literal">g</code> to be
used within the body of another meta-node <code class="literal">f</code> even if the definition
of <code class="literal">g</code> appears after the definition of <code class="literal">f</code>. Effectively this allows
for mutual recursion.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_optional_arguments"></a>Optional Arguments</h4></div></div></div><p><a id="idm371439197840" class="indexterm"></a>
<a id="idm371439196336" class="indexterm"></a>
<a id="idm371439195088" class="indexterm"></a></p><p>A node in the argument list, of a meta-node definition, may also be of
the form <code class="literal">name : value</code>. This designates that the argument, which is
bound to local node <code class="literal">name</code>, is optional. If it is omitted, in an
instance of the meta-node, the local argument node is set to <code class="literal">value</code>
instead.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">value</code> is processed in the global scope as the meta-node
definition is processed. Thus <code class="literal">value</code> cannot (as of yet), refer to the
preceding argument nodes of the meta-node.</p></td></tr></table></div><p>The <code class="literal">value</code> may be omitted, written in prefix form <code class="literal">:(name)</code>, in which
case if the argument is omitted, the local argument node is set to a
failure, <span class="emphasis"><em>see <a class="xref" href="ar01s02.html#_failures" title="2.6. Failures">Section 2.6, “Failures”</a></em></span>.</p><p><strong>Example. </strong>
</p><pre class="screen"># Increment `x` by 1 or given delta

inc(x, d : 1) : x + d

# Increment `a` by default delta 1
inc(a)

# Increment `b` by explicit delta 2
inc(b, 2)</pre><p>
</p><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Optional arguments may only be followed by optional
arguments or a rest argument. An optional argument may not be followed
by a required argument.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_rest_arguments"></a>Rest Arguments</h4></div></div></div><p><a id="idm371439183360" class="indexterm"></a>
<a id="idm371439181856" class="indexterm"></a>
<a id="idm371439180608" class="indexterm"></a></p><p>The last node in the argument list, of a meta-node definition, may
also be of the form <code class="literal">..(name)</code>. This designates that the local node
<code class="literal">name</code> is bound to the list containing the remaining arguments, on
which the meta-node is applied, after the last optional or required
argument. This allows for a variable number of arguments.</p><p><strong>Example. </strong>
</p><pre class="screen"># Add `n` to each remaining argument

add-n(n, ..(xs)) : {
    inc(x) : x + n
    map(inc, xs)
}</pre><p>
</p><p>See <a class="xref" href="ar01s05.html#_lists" title="5.9. Lists">Section 5.9, “Lists”</a> for the documentation of lists and the list processing
functions.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="local_nodes"></a>Local Nodes</h4></div></div></div><p><a id="idm371439173632" class="indexterm"></a>
<a id="idm371439172128" class="indexterm"></a>
<a id="idm371439170880" class="indexterm"></a></p><p>Nodes local to the meta-node’s definition may only be referenced from
within the definition itself even if they have the same identifiers as
global nodes. Local nodes are created for each of the argument nodes.</p><p>A node reference, within the definition of a meta-node, primarily
refers to the local node. If there is no local node with that
identifier, it refers to the node in the enclosing scope. If the
enclosing scope does not contain a node with that identifier, the
scope’s enclosing scope is searched until the global scope is
reached. If the node is not found in any enclosing scope a compilation
error is triggered.</p><p>Local nodes are created if they appear as the target of a binding,
whether implicit or explicit. This is the means by which local nodes,
storing intermediate results are created.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The node creation rules inside meta-node definitions differ from
the node creation rules at the global scope.</p></td></tr></table></div><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>A global node, with the same identifier as a local node, can be
referenced using the outer <code class="literal">..</code> operator.</p></td></tr></table></div><p><strong>Example: Local Nodes. </strong>
</p><pre class="screen">a + b -&gt; x
x + y -&gt; n

addx(n) : {
    # `n` refers to the local argument node `n`, not the global `n`
    # `x` refers to the global node `x`
    n + x
}</pre><p>
</p><p><strong>Example: Meta-Nodes. </strong>
</p><pre class="screen">1-(n) : n - 1

factorial(n) :
    case (
        # The `1-` refers to the global `1-` meta-node
        n &gt; 1 : n * factorial(1-(n)),
        1
    )</pre><p>
</p><p><strong>Example: Local nodes storing intermediate results. </strong>
</p><pre class="screen">x + 1 -&gt; next

factorial(n) :

    # A local node `next` is created since it appears as the target of
    # a binding. `next` does not refer to the global node of the same
    # name.

    n - 1 -&gt; next

    case (
        n &gt; 1 : n * factorial(next),
        1
    )</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_self_node"></a>Self Node</h4></div></div></div><p><a id="idm371439158752" class="indexterm"></a>
<a id="idm371439157248" class="indexterm"></a>
<a id="idm371439156000" class="indexterm"></a></p><p>The special <code class="literal">self</code> node is a local node which represents the
meta-node’s value. This node can be used to set the value, returned by
the meta-node, using explicit bindings.</p><p>When an explicit binding to <code class="literal">self</code> is established, the meta-node no
longer returns the value of the last node in its definition.</p><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>A meta-node may not have more than a single context, <span class="emphasis"><em>see
<a class="xref" href="ar01s02.html#_contexts" title="2.5. Contexts">Section 2.5, “Contexts”</a></em></span>, as it is ambiguous which context’s value
function to use as the meta-node function.</p></td></tr></table></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>In the absence of an explicit binding to <code class="literal">self</code>, the last node
in the meta-node’s definition is implicitly bound to <code class="literal">self</code>.</p></td></tr></table></div><p><strong>Example. </strong>
</p><pre class="screen">factorial(n) : {
    n * factorial(n - 1) -&gt; next
    case (n &gt; 1 : next, 1) -&gt; self <a id="CO2-1"></a><span><img src="images/icons/callouts/1.png" alt="1" border="0" /></span>
}</pre><p>
</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO2-1"><span><img src="images/icons/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>
Explicit binding to <code class="literal">self</code>.
</p></td></tr></table></div><p>In the example, above, the value returned by the <code class="literal">factorial</code> meta-node
is set by an explicit binding to the <code class="literal">self</code> node. The meta-node no
longer evaluates to the value of the last node in the declaration
list.</p><p>The <code class="literal">self</code> node is particularly useful for creating a dictionary of
values to which the meta-node evaluates to, <span class="emphasis"><em>see <a class="xref" href="ar01s02.html#_subnodes" title="2.9. Subnodes">Section 2.9, “Subnodes”</a></em></span>:</p><p><strong>Example: Creating Dictionaries. </strong>
</p><pre class="screen">Person(first, last): {
    first -&gt; self.first-name
    last -&gt; self.last-name
}</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_nested_meta_nodes"></a>Nested Meta-Nodes</h4></div></div></div><p><a id="idm371439138528" class="indexterm"></a>
<a id="idm371439137024" class="indexterm"></a>
<a id="idm371439135776" class="indexterm"></a></p><p>The body of a meta-node can contain other meta-node definitions nested
inside it. These meta-nodes are local to the body, and can only be
used inside it, even if the same meta-node identifier appears in an
expression outside the body. If a meta-node with the same identifier
is already defined at global scope, the nested meta-node shadows it in
the scope of the body. This means that references to the meta-node
within the body refer to the nested meta-node and not the global node.</p><p><strong>Example: Factorial with Nested Tail-Recursive Helper Meta-Node. </strong>
</p><pre class="screen">factorial(n) : {
    # `iter` is local to `factorial`
    iter(n, acc) : {
        case (
            n &gt; 1 : iter(n - 1, n * acc),
            acc
        )
    }

    iter(n, 1)
}</pre><p>
</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_recursive_meta_nodes"></a>3.2. Recursive Meta-Nodes</h3></div></div></div><p><a id="idm371439130656" class="indexterm"></a>
<a id="idm371439129504" class="indexterm"></a>
<a id="idm371439128512" class="indexterm"></a>
<a id="idm371439127264" class="indexterm"></a></p><p>Meta-nodes may be recursive and mutually recursive, i.e. when a
meta-node <code class="literal">f</code> contains an instance of another meta-node <code class="literal">g</code> in its
definition, and <code class="literal">g</code> contains an instance of <code class="literal">f</code> in its definition.</p><p>Each call to a meta-node consumes an amount of stack space. Further
calls, within the meta-node, increase the amount of stack space if
they are strictly evaluated. However, if a call to a meta-node is
conditionally evaluated, i.e. lazily, it does not increase the amount
of stack space used, since a <span class="emphasis"><em>thunk</em></span> is returned, rather than the
final result, thus freeing the amount of stack space used by the
current call. <span class="emphasis"><em>See <a class="xref" href="ar01s02.html#_evaluation_strategy" title="2.4. Evaluation Strategy">Section 2.4, “Evaluation Strategy”</a></em></span>.</p><p>The following are examples of meta-nodes in which one or more of the
arguments are evaluated lazily:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
In the <code class="literal">if</code> meta-node, from the <a class="link" href="ar01s05.html" title="5. Core Module"><code class="literal">core</code></a> module, the <code class="literal">if-true</code> and
<code class="literal">if-false</code> arguments are evaluated lazily since only one of the
arguments is actually evaluated, depending on the value of the first
<code class="literal">test</code> argument. The <code class="literal">test</code> argument is evaluated strictly as its
value is always required in order to compute the return value of the
meta-node.
</p><pre class="screen">if(test, if-true, if-false)</pre></li><li class="listitem"><p class="simpara">
In the <code class="literal">and</code> and <code class="literal">or</code> meta-nodes, from the <a class="link" href="ar01s05.html" title="5. Core Module"><code class="literal">core</code></a>
  module, the first argument is strictly evaluated however the second
  is lazily evaluated, as whether it is actually evaluated depends on
  the value of the first argument.
</p><pre class="screen">and(a, b)
or(a, b)</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_outer_node_references"></a>3.3. Outer Node References</h3></div></div></div><p><a id="idm371439108944" class="indexterm"></a>
<a id="idm371439107696" class="indexterm"></a>
<a id="idm371439106704" class="indexterm"></a>
<a id="idm371439105200" class="indexterm"></a>
<a id="idm371439103952" class="indexterm"></a></p><p>The value of a node, declared in the global scope, can be referenced
from within a meta-node, either directly by its identifier, as
described in <a class="xref" href="ar01s03.html#local_nodes" title="Local Nodes">Local Nodes</a>, or with the outer node reference
operator (<code class="literal">..</code>). This is a special operator which takes a node
identifier as an argument and searches for a node with that
identifier, in each enclosing scope, starting from the scope in which
the meta-node is defined. The first node found is referenced.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>It is not necessary for the node to have been declared prior to
the meta-node definition, as meta-node definitions are only processed
after all declarations in the source file have been
processed. However, in general the node should be declared in the same
source file.</p></td></tr></table></div><p><strong>Example. </strong>
</p><pre class="screen">n

# ..(n) references the global node `n`
addn(n): n + ..(n)</pre><p>
</p><p>Referenced outer nodes, whether implicitly or by the <code class="literal">..</code> operator,
are treated as additional hidden arguments, that are added to the
argument list of each instance of the meta-node. The result is that
any change in the values of the referenced nodes, will trigger a value
update in each instance of the meta-node.</p><p>The previous example can be thought of as:</p><pre class="screen"># Not valid syntax.

# Illustrates that outer node references are equivalent to additional
# arguments.

addn(n, ..(n)) : n + ..(n)</pre><p>Thus the value of <code class="literal">n</code> is appended to the argument list of all
instances of <code class="literal">addn</code>, e.g. <code class="literal">addn(node)</code> becomes <code class="literal">addn(node, n)</code>.</p><p>Meta-nodes reference all outer nodes referenced by the meta-nodes
which are used in their body. In the previous example, if a meta-node
makes use of <code class="literal">addn</code>, it will also reference the node <code class="literal">n</code> declared in
the global scope.</p><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Whilst the value of an outer-node can be referenced from
within the body of a meta-node, bindings with the node as the target
cannot be established, from within the body of the meta-node.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_external_meta_nodes"></a>3.4. External Meta-Nodes</h3></div></div></div><p><a id="idm371439088448" class="indexterm"></a>
<a id="idm371439087200" class="indexterm"></a></p><p>External meta-nodes are meta-nodes without a definition. They are used
to call external functions defined outside of Tridash code. The
special <code class="literal">:extern</code> declaration creates a meta-node without a
definition.</p><p><strong>Syntax. </strong>
</p><pre class="screen">:extern(id, args...)</pre><p>
</p><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">id</code>
</p>
</td><td style="" valign="top">
<p>
The meta-node identifier
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">args</code>
</p>
</td><td style="" valign="top">
<p>
The argument list
</p>
</td></tr></tbody></table></div><p>The argument list has to be provided in order for the arity of the
meta-node to be known. The same rules apply for external meta-node
argument lists as for ordinary meta-node argument lists. Symbols
designate required arguments, arguments of the form <code class="literal">:(arg, value)</code>
designate optional arguments and <code class="literal">..(rest)</code> designates a rest
argument. The argument identifiers, however, do not name local nodes.</p><p>An external definition for the meta-node has to be provided, and
linked with the generated code. In the JavaScript backend, instances
of the meta-node are compiled to a call to the JavaScript function
with the same name as the node identifier. If the <code class="literal">public-name</code>
attribute of the meta-node is set, a call to the JavaScript function
with the value of the attribute is generated instead.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_higher_order_meta_nodes"></a>3.5. Higher-Order Meta-Nodes</h3></div></div></div><p><a id="idm371436957488" class="indexterm"></a>
<a id="idm371436956240" class="indexterm"></a>
<a id="idm371436955248" class="indexterm"></a>
<a id="idm371436954000" class="indexterm"></a></p><p>An atom node expression consisting of the meta-node itself references
the meta-node’s function as a value. This function can be passed to
other meta-nodes as an argument, or bound to another node.</p><p>In a functor expression, in which the operator is not a meta-node but
is an ordinary node, the function stored in the node’s value is
called. If the operator node does not evaluate to a function, the
entire functor node fails to evaluate to a value, <span class="emphasis"><em>see <a class="xref" href="ar01s02.html#_failures" title="2.6. Failures">Section 2.6, “Failures”</a></em></span>.</p><p><strong>Example: Binding Meta-Node to other Nodes. </strong>
</p><pre class="screen">inc(x) : x + 1

inc -&gt; f   <a id="CO3-1"></a><span><img src="images/icons/callouts/1.png" alt="1" border="0" /></span>
f(a) -&gt; x  <a id="CO3-2"></a><span><img src="images/icons/callouts/2.png" alt="2" border="0" /></span></pre><p>
</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO3-1"><span><img src="images/icons/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>
Value function of <code class="literal">inc</code> meta-node bound to <code class="literal">f</code> node.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO3-2"><span><img src="images/icons/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>
Function stored in <code class="literal">f</code> meta-node applied on argument <code class="literal">a</code>.
</p></td></tr></table></div><p><span class="emphasis"><em>See <a class="xref" href="ar01s03.html#_outer_node_references" title="3.3. Outer Node References">Section 3.3, “Outer Node References”</a> for an example in which a meta-node is
passed as an argument to another meta-node.</em></span></p><p>The function of a meta-node which does not have optional arguments or
outer nodes is effectively a constant, as is the case with the <code class="literal">inc</code>
meta-node in the example above. If, however, the meta-node references
outer nodes, a reference to the meta-node’s function also references
the values of the outer nodes. As such, if a node is bound to the
meta-node’s function, a binding between the outer nodes and the node
is also established.</p><p><strong>Example: Reference Meta-Node Function with Outer Nodes. </strong>
</p><pre class="screen"># Increments `x` by the global `delta`
inc(x) : x + delta

inc -&gt; f
f(a) -&gt; x</pre><p>
</p><p>In the example, above, node <code class="literal">f</code> is bound to the value function of
<code class="literal">inc</code>. However, since <code class="literal">inc</code> references the global <code class="literal">delta</code> node, a
binding between <code class="literal">f</code> and <code class="literal">delta</code> is also established. The value
function of <code class="literal">f</code> creates a function which invokes the <code class="literal">inc</code> with the
value of <code class="literal">delta</code>. As a result, when the value of <code class="literal">delta</code> changes, the
value of <code class="literal">f</code> is recomputed, and likewise the value of <code class="literal">f(a)</code> is
recomputed.</p><p>The same semantics apply for optional arguments with default values
which are not constant literals.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_macro_nodes"></a>3.6. Macro Nodes</h3></div></div></div><p><a id="idm371436929136" class="indexterm"></a>
<a id="idm371436927888" class="indexterm"></a>
<a id="idm371436926896" class="indexterm"></a>
<a id="idm371436925392" class="indexterm"></a>
<a id="idm371436924144" class="indexterm"></a>
<a id="idm371436923152" class="indexterm"></a>
<a id="idm371436921648" class="indexterm"></a>
<a id="idm371436920400" class="indexterm"></a></p><p>A macro-node is a meta-node which is evaluated at compile-time with
the result is interpreted as a Tridash node declaration.</p><p>A meta-node is marked as a macro-node by setting the <code class="literal">macro</code> attribute
to true. Once set, the meta-node’s function will be evaluated when
each instance of the meta-node is processed. The arguments passed to
the function are the raw argument node expressions of the functor node
expression.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Attributes are set on meta-nodes in the same way as they are set for
ordinary nodes. The <code class="literal">macro</code> attribute of a meta-node <code class="literal">f</code> is set to
<span class="emphasis"><em>true</em></span>, with the following declaration:</p><pre class="screen">:attribute(f, macro, 1)</pre></td></tr></table></div><p>Atom node expressions are represented by a special symbol type and
functor node expressions are represented as a list with the operator
in the first element of the list.</p><p>The return value of the meta-node function is processed as though it
is a parsed node declaration appearing in source code.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_literal_symbols"></a>Literal Symbols</h4></div></div></div><p><a id="idm371436911936" class="indexterm"></a>
<a id="idm371436910688" class="indexterm"></a>
<a id="idm371436909696" class="indexterm"></a>
<a id="idm371436908192" class="indexterm"></a>
<a id="idm371436906944" class="indexterm"></a></p><p>The special <code class="literal">:quote</code> operator returns its argument, treated as a
literal symbol rather than a node expression.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The <code class="literal">'</code> macro from the core module is the preferred shorthand for
the <code class="literal">:quote</code> operator.</p></td></tr></table></div><p><strong>Example. </strong>
</p><pre class="screen"># This is interpreted as the literal symbol `x` rather than the node
# with identifier `x`.

:quote(x)

# The following is a shorthand for the above
'(x)</pre><p>
</p><p>These can be used inside macro nodes to insert literal node or
operator names.</p><p><strong>Example: Definition of <code class="literal">'</code> macro. </strong>
</p><pre class="screen">'(thing) :
    list(:quote(:quote), thing)

:attribute(', macro, 1)</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="node_references"></a>Node References</h4></div></div></div><p><a id="idm371436897296" class="indexterm"></a>
<a id="idm371436896048" class="indexterm"></a>
<a id="idm371436895056" class="indexterm"></a>
<a id="idm371436893552" class="indexterm"></a>
<a id="idm371436892304" class="indexterm"></a></p><p>Generally a macro-node expands to a declaration involving some other
meta-node. The meta-node might not be located in the same module, <span class="emphasis"><em>see
<a class="xref" href="ar01s04.html" title="4. Modules">Section 4, “Modules”</a></em></span>, as the module in which the macro-node instance
occurs. Using the quote operator to generate a declaration involving
the meta-node may result in a compilation error, if the meta-node is
not present in the module in which the macro-node instance occurs, or
may result in a node declaration involving an entirely different
meta-node, if the module contains a node with the same identifier.</p><p>Node objects can be referenced directly with the node reference
operator, <code class="literal">&amp;</code>. When the declaration returned by a macro-node contains
a raw node object, no node lookup is done and the raw node object is
used as though it has been returned by node lookup. This is useful in
macros as the node is looked up once in the module containing the
macro-node’s definition.</p><p><strong>Example: Definition of <code class="literal">&lt;-</code> Macro. </strong>
</p><pre class="screen">&lt;-(target, src) :
    list(&amp;(-&gt;), src, target)

:attribute(&lt;-, macro, 1)</pre><p>
</p><p>The <code class="literal">&lt;-</code> macro function, in the example above, returns a functor
expression where the operator is the node object <code class="literal">-&gt;</code>. When the
functor expression is processed, the operator is taken to be the <code class="literal">-&gt;</code>
node, rather than the node with identifier <code class="literal">-&gt;</code> in the module in which
the instance is processed.</p><p>Any node can be referenced including ordinary nodes and
macro-nodes. Special operators, however, cannot be referenced and have
to be returned as quoted symbols instead. There is no issue with
directly quoting the special operator’s identifier, in expressions
returned by macros, as there is for meta-nodes since the meaning of a
special operator cannot be overridden and does not change with the
module. Most of the <span class="emphasis"><em>special operators</em></span> mentioned till this point,
which are not an identifier prefixed with <code class="literal">:</code>, such as <code class="literal">-&gt;</code>, <code class="literal">:</code>, <code class="literal">&amp;</code>,
<code class="literal">.</code>, <code class="literal">..</code> are actually builtin macro nodes which expand to an internal
special declaration, thus can be referenced with the <code class="literal">&amp;</code>
operator. Special operators beginning with <code class="literal">:</code>, such as <code class="literal">:attribute</code>,
<code class="literal">:op</code>, <code class="literal">:module</code> are actual special operators and cannot be referenced
with <code class="literal">&amp;</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_instances_as_targets"></a>3.7. Instances as Targets</h3></div></div></div><p><a id="idm371436871680" class="indexterm"></a>
<a id="idm371436870432" class="indexterm"></a>
<a id="idm371436869440" class="indexterm"></a>
<a id="idm371436867936" class="indexterm"></a>
<a id="idm371436866688" class="indexterm"></a></p><p>By default, a meta-node instance appearing as the target of a binding,
that is on the right hand side of the <code class="literal">-&gt;</code> operator, will result in a
compilation error. You may have noticed, however, that some meta-nodes
in the <a class="link" href="ar01s05.html" title="5. Core Module"><code class="literal">core</code></a> module, can also appear as targets of
a binding, particularly <a class="link" href="ar01s05.html#meta-node-to-int" title="Meta-Node: to-int(x)"><code class="literal">to-int</code></a>,
<a class="link" href="ar01s05.html#meta-node-to-real" title="Meta-Node: to-real(x)"><code class="literal">to-real</code></a> and <a class="link" href="ar01s05.html#meta-node-to-string" title="Meta-Node: to-string(x)"><code class="literal">to-string</code></a>. This is achieved by setting the <code class="literal">target-node</code>
attribute.</p><p>The <code class="literal">target-node</code> attribute stores the meta-node, which is applied on
the value of the meta-node instance, in order to compute the value of
the arguments. When the <code class="literal">target-node</code> attribute is set, a binding is
established between the meta-node instance, as the dependency, and
each argument node, as the observer. The function of the binding
context is set to the meta-node stored in the <code class="literal">target-node</code> attribute.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The <code class="literal">target-node</code> meta-node is looked up immediately when the
attribute is set, and in the same module in which the <code class="literal">:attribute</code>
declaration is processed.</p></td></tr></table></div><p>As an example consider a meta-node <code class="literal">f</code> with the <code class="literal">target-node</code>
attribute set to <code class="literal">g</code>. A declaration of the form:</p><pre class="screen">x -&gt; f(arg)</pre><p>results in the following binding also being established, alongside the
main binding of <code class="literal">arg -&gt; f(arg)</code>:</p><pre class="screen">g(f(arg)) -&gt; arg</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The functor node <code class="literal">g(f(arg))</code> is not created, rather <code class="literal">f(arg)</code> is
bound to <code class="literal">arg</code> directly and <code class="literal">g</code> is set as the value function.</p></td></tr></table></div><p>This is useful for creating <span class="emphasis"><em>invertable</em></span> meta-nodes where instead of
computing a result given the values of the argument nodes, the values
of the argument nodes can be computed given the result. This is
achieved by binding to the meta-node instance, with the <code class="literal">target-node</code>
attribute set to the <span class="emphasis"><em>inverse</em></span> function.</p><p>The <a class="link" href="ar01s05.html#meta-node-to-int" title="Meta-Node: to-int(x)"><code class="literal">to-int</code></a> meta-node from the <code class="literal">core</code> module
has its <code class="literal">target-node</code> attribute set to <code class="literal">int</code>. Thus the binding <code class="literal">x -&gt;
to-int(y)</code>, will result in the value of <code class="literal">y</code> being set to the value
<code class="literal">int(x)</code>, on changes in the value of <code class="literal">x</code>.</p><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>In order for the bindings to the argument nodes, to be
established, the <code class="literal">:attribute</code> declaration which sets the <code class="literal">target-node</code>
attribute must occur before the first instance of the
meta-node, however after the meta-node is defined.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_target_node_transforms"></a>3.8. Target Node Transforms</h3></div></div></div><p><a id="idm371436838672" class="indexterm"></a>
<a id="idm371436837168" class="indexterm"></a>
<a id="idm371436835920" class="indexterm"></a>
<a id="idm371436834928" class="indexterm"></a>
<a id="idm371436833424" class="indexterm"></a>
<a id="idm371436832176" class="indexterm"></a></p><p>The <code class="literal">target-node</code> attribute allows for a binding of a simple function
to be established in the reverse direction, from the meta-node
instance to its arguments. However, it lacks the functionality for
setting a different function for each argument or generating more
complex binding declarations.</p><p>The <code class="literal">target-transform</code> attribute allows a meta-node to be set as the
function which is called whenever an instance of the meta-node appears
as the target of a binding. The function is called with two arguments:
the <span class="emphasis"><em>source</em></span> node of the binding and the functor expression, which
appears as the <span class="emphasis"><em>target</em></span> of the binding. The function should return a
declaration which is processed instead of the binding declaration. The
result is processed as though it appears at top-level and unlike with
a macro-node, the result is not substituted directly in the place of
the meta-node instance.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The <span class="emphasis"><em>source</em></span> argument is not necessarily the actual source node
declaration but is generally an atom node, with a randomly generated
identifier, which should serve as the source node for the binding
declarations generated by the <code class="literal">target-transform</code> node.</p></td></tr></table></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s02.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s04.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>