<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9. Contexts</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Tridash Tutorials" /><link rel="up" href="index.html" title="Tridash Tutorials" /><link rel="prev" href="ar01s08.html" title="8. Target Node Transforms" /><link rel="next" href="ar01s10.html" title="10. Node States" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ar01s08.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s10.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="contexts"></a>9. Contexts</h2></div></div></div><p>Throughout these tutorials, we’ve glossed over two-way bindings
without going into much detail of how they work, yet they were a vital
component of every application as the bindings to the UI elements have
all been two-way bindings.</p><p>Each node has a number of <span class="emphasis"><em>contexts</em></span> which store information about how
to compute the node’s value, i.e. what function to use and what
dependencies are operands to the function. The <span class="emphasis"><em>active</em></span> context of a
node, at a given moment in time, is the context which is used to
compute the node’s value. In general, a context is <span class="emphasis"><em>activated</em></span> when
the value of an operand node of the context changes. By default, a
node context is created for each dependency of a node which was added
by an explicit binding.</p><p><strong>Example. </strong>
</p><pre class="screen">a -&gt; x # Context created for dependency `a`
b -&gt; x # Context created for dependency `b`
c -&gt; x # Context created for dependency `c`</pre><p>
</p><p>In this example node <code class="literal">x</code> has three contexts one for each of its
dependency nodes, <code class="literal">a</code>, <code class="literal">b</code> and <code class="literal">c</code>, to which it is bound explicitly.</p><p>An implicit binding between a meta-node instance and the meta-node
arguments does not result in the creation of a context for each
operand.</p><pre class="screen">a + b</pre><p>Nodes <code class="literal">a</code> and <code class="literal">b</code> are implicitly added as dependencies of <code class="literal">a + b</code>
however they are added as operands to the same context with the <code class="literal">+</code>
function.</p><p>The following application demonstrates how different contexts are
activated, when the values of their operand nodes change.</p><p><strong><code class="literal">ui.html</code>. </strong>
</p><pre class="programlisting">&lt;?
 x -&gt; node
 y -&gt; node
 z -&gt; node
?&gt;
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Node Contexts&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;div&gt;&lt;label&gt;X: &lt;input value="&lt;?@ x ?&gt;"/&gt;&lt;/label&gt;&lt;/div&gt;
      &lt;div&gt;&lt;label&gt;Y: &lt;input id="b" value="&lt;?@ y ?&gt;"/&gt;&lt;/label&gt;&lt;/div&gt;
      &lt;div&gt;&lt;label&gt;Z: &lt;input value="&lt;?@ z ?&gt;"/&gt;&lt;/label&gt;&lt;/div&gt;
      &lt;hr/&gt;
      &lt;div&gt;&lt;strong&gt;Last value entered: &lt;?@ node ?&gt;&lt;/strong&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p>
</p><p>This is a simple application consisting of three text input fields
bound to nodes <code class="literal">x</code>, <code class="literal">y</code> and <code class="literal">z</code>. Nodes <code class="literal">x</code>, <code class="literal">y</code> and <code class="literal">z</code> are each
explicitly bound to <code class="literal">node</code>, the value of which is displayed below the
fields.</p><p>Let’s enter a value in each field and see what happens. Observe the
value displayed below the fields after each change:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap1.png" align="middle" alt="X: 1, Y: _, Z: _, Last value entered: 1" /></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap2.png" align="middle" alt="X: 1, Y: 2, Z: _, Last value entered: 2" /></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap3.png" align="middle" alt="X: 1, Y: 2, Z: 3, Last value entered: 3" /></div></div><p>Notice that after each change, the value that was just entered is
displayed.</p><p>Now let’s try changing the values of the fields which were edited
previously:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap4.png" align="middle" alt="X: 1, Y: 10, Z: 3, Last value entered: 10" /></div></div><p>In this case the value of the second field, <span class="emphasis"><em>Y</em></span>, was changed to 10 and
that value was immediately displayed below the fields.</p><p>The value of the field that was changed last is displayed. To
understand why this is so, let’s examine the sequence of steps taken
when a value is entered in the <span class="emphasis"><em>X</em></span> field.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
The value of <code class="literal">x</code>, which is bound to the value in the <span class="emphasis"><em>X</em></span> field, is
updated.
</li><li class="listitem">
The context corresponding to the binding <code class="literal">x -&gt; node</code> is activated
due to the value of <code class="literal">x</code> being updated.
</li><li class="listitem">
The value of <code class="literal">node</code> is updated to the value of <code class="literal">x</code>.
</li></ol></div><p>Contexts make two-way bindings possible:</p><p><strong>Example. </strong>
</p><pre class="screen">input1 -&gt; a

# Two-way binding
a -&gt; b; a -&gt; b

input2 -&gt; b</pre><p>
</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The <code class="literal">;</code> character separates multiple declarations written on a
single line.</p></td></tr></table></div><p><code class="literal">a</code> has two contexts corresponding to dependency nodes <code class="literal">input1</code> and
<code class="literal">a</code> (which is also an observer). <code class="literal">b</code> has two contexts corresponding to
dependency nodes <code class="literal">input2</code> and <code class="literal">a</code>.</p><p>When <code class="literal">input1</code> is changed, the contexts corresponding to the bindings
in the following direction are activated:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">input1 -&gt; a</code>
</li><li class="listitem">
<code class="literal">a -&gt; b</code>
</li></ul></div><p>When <code class="literal">input2</code> is changed, the contexts corresponding to the bindings
in the following direction are activated:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">input2 -&gt; b</code>
</li><li class="listitem">
<code class="literal">b -&gt; a</code>
</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_explicit_contexts"></a>9.1. Explicit Contexts</h3></div></div></div><p>The context of a binding can be set explicitly to a named context,
using the <code class="literal">@</code> operator from the <code class="literal">core</code> module.</p><pre class="screen">a -&gt; b @ context-id</pre><p>The binding <code class="literal">a -&gt; b</code> is established in the context, of <code class="literal">b</code>, with
identifier <code class="literal">context-id</code>.</p><p>When multiple bindings are established to the same explicit context,
the observer node takes on the value of the first operand which does
not evaluate to a failure. The operands are ordered by the order in
which the explicit bindings are declared in the source file. If all
the operands evaluate to failures, the node evaluates to the failure
value of the last operand.</p><p>This is better explained with an example application:</p><p><strong><code class="literal">ui.html</code>. </strong>
</p><pre class="programlisting">&lt;?
 /import(core)

 x -&gt; node @ context
 y -&gt; node @ context
 z -&gt; node @ context
?&gt;
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Explicit Contexts&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;div&gt;&lt;label&gt;X: &lt;input value="&lt;?@ to-int(x) ?&gt;"/&gt;&lt;/label&gt;&lt;/div&gt;
      &lt;div&gt;&lt;label&gt;Y: &lt;input value="&lt;?@ to-int(y) ?&gt;"/&gt;&lt;/label&gt;&lt;/div&gt;
      &lt;div&gt;&lt;label&gt;Z: &lt;input value="&lt;?@ to-int(z) ?&gt;"/&gt;&lt;/label&gt;&lt;/div&gt;
      &lt;hr/&gt;
      &lt;div&gt;&lt;strong&gt;Value: &lt;?@ node ?&gt;&lt;/strong&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p>
</p><p>This application is similar to the previous application except the
bindings from nodes <code class="literal">x</code>, <code class="literal">y</code> and <code class="literal">z</code>, to <code class="literal">node</code> are established in an
explicit context with identifier <code class="literal">context</code>. Additionally the input
fields are bound to <code class="literal">to-int</code> instances, of <code class="literal">x</code>, <code class="literal">y</code> and <code class="literal">z</code> which
results in <code class="literal">x</code>, <code class="literal">y</code> and <code class="literal">z</code> being bound to the values entered in the
fields converted to integers. If a non-integer value is entered in a
field, the corresponding node is bound to a failure value.</p><p>Let’s try it out. Enter some integer values in each of the fields:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap5.png" align="middle" alt="X: 1, Y: 2, Z: 3, Value: 1" /></div></div><p>The value entered in the first field, <span class="emphasis"><em>X</em></span>, was displayed. Since a
valid integer was entered, node <code class="literal">x</code> evaluates to the integer value
1. The binding <code class="literal">x -&gt; node</code> was established first, as the declaration
occurs first in the source file, and since <code class="literal">x</code> does not evaluate to a
failure, <code class="literal">node</code> takes on the value of <code class="literal">x</code>. The values of <code class="literal">y</code> and <code class="literal">z</code>
are ignored.</p><p>Now let’s change <code class="literal">x</code> to a non-integer value:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap6.png" align="middle" alt="X: foo, Y: 2, Z: 3, Value: 2" /></div></div><p>The value entered in the second field, 2, is displayed. Since a
non-integer value was entered in the first field, <code class="literal">x</code> evaluates to a
failure. <code class="literal">node</code> thus takes on the value of the next dependency, bound
to the explicit context, which does not evaluate to a failure. The
dependency is <code class="literal">y</code> which evaluates to the integer entered in the second
field, 2.</p><p>Let’s see what happens if we enter a non-integer value in the third
field:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap7.png" align="middle" alt="X: foo, Y: 2, Z: bar, Value: 2" /></div></div><p>The displayed value is unchanged since the second dependency, node
<code class="literal">y</code>, already evaluates to a value which is not a failure value. The
value of the third dependency <code class="literal">z</code>, corresponding to the value entered
in the third field, is ignored, regardless of whether it evaluates to
a failure or not.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_handling_failures_with_explicit_contexts"></a>9.2. Handling Failures with Explicit Contexts</h3></div></div></div><p>Explicit contexts are a useful tool for handling failures. In the
previous application a failure originating from the first input field,
was handled by taking the value of the node bound to the second
field. Similarly a failure originating from the second input field is
handled by taking the value entered in the third field.</p><p>The <code class="literal">@</code> operator also allows a binding to be activated only if the
result of the previous binding(s), in the same context, is a failure
value with a given type. When the context identifier is of the form
<code class="literal">when(context, type)</code> the binding is only activated if the result of
the previous binding(s) is a failure of type <code class="literal">type</code>.</p><p><strong>Example. </strong>
</p><pre class="screen">x -&gt; node @ context
y -&gt; node @ when(context, Invalid-Integer)
z -&gt; node @ when(context, Negative-Number)</pre><p>
</p><p>Three bindings to <code class="literal">node</code> are established in the explicit context
<code class="literal">context</code>.</p><p><code class="literal">node</code> is primarily bound to the value of <code class="literal">x</code> if it does not evaluate
to a failure. If <code class="literal">x</code> evaluates to a failure of type <code class="literal">Invalid-Integer</code>,
<code class="literal">node</code> is bound to the value of <code class="literal">y</code>. If <code class="literal">x</code>, or <code class="literal">y</code> evaluate to a
failure of type <code class="literal">Negative-Number</code>, then <code class="literal">node</code> is bound to the value
of <code class="literal">z</code>.</p><p>To try this out replace the binding declarations, in the application
from the previous section, with the declarations in the example
above. Also copy over the definition of the meta-nodes <code class="literal">valid-int</code>,
<code class="literal">validate</code> and the <code class="literal">Negative-Number</code> failure type from
<a class="xref" href="ar01s08.html#target-node-own-meta-nodes" title="8.3. Target-Node for own Meta-Nodes">Section 8.3, “Target-Node for own Meta-Nodes”</a>, into the Tridash code tag. Replace
<code class="literal">to-int</code> with <code class="literal">valid-int</code> in the inline node declarations within the
input field values.</p><p>Enter a non-integer value in the first field, and an integer value in
the second and third fields:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap8.png" align="middle" alt="X: foo, Y: 1, Z: 2, Value: 1" /></div></div><p>The value of the second field is displayed, since <code class="literal">node</code> is bound to
it when the value in the first field is not an integer.</p><p>Now change the value of the second field to a negative integer, or
alternatively enter a negative integer value in the first field:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap9.png" align="middle" alt="X: foo, Y: -1, Z: 2, Value: 2" /></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial9/snap10.png" align="middle" alt="X: -1, Y: 1, Z: 2, Value: 2" /></div></div><p>The value of the third field is displayed in both cases, even when the
value of the second field is a valid positive integer. This is due to
<code class="literal">node</code> being bound to the value of the third field when either the
value of the first field or second field is a negative number.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">when</code> is registered as an infix operator thus the following:</p><pre class="screen">a -&gt; b @ when(context, type)</pre><p>can be rewritten as:</p><pre class="screen">a -&gt; b @ context when type</pre></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="adding-numbers-improved-error-handling"></a>9.3. Improved Error Handling in <span class="emphasis"><em>Adding Numbers</em></span></h3></div></div></div><p>Whilst the error handling logic in the <span class="emphasis"><em>Adding Numbers</em></span> application,
from <a class="xref" href="ar01s08.html" title="8. Target Node Transforms">Section 8, “Target Node Transforms”</a>, is adequate and correct, the
definition of the <code class="literal">error-message</code> meta-node, responsible for selecting
an appropriate error message, can be improved using explicit
contexts. The current definition repeatedly checks whether the failure
type of the <code class="literal">value</code> argument is of a given type using the <code class="literal">fail-type?</code>
meta-node. This is repetitive and does not convey the intent that this
is error handling/reporting logic.</p><p>The <code class="literal">error-message</code> meta-node returns:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The empty string if the <code class="literal">value</code> argument does not evaluate to a
  failure.
</li><li class="listitem">
The string “Not a valid number!” when <code class="literal">value</code> evaluates to a
  failure of type <code class="literal">Invalid-Integer</code>.
</li><li class="listitem">
The string “Number must be greater than or equal to 0!” when
  <code class="literal">value</code> evaluates to a failure of type <code class="literal">Negative-Number</code>.
</li></ul></div><p>We can re-implement this logic using bindings to the <code class="literal">self</code> node with
explicit contexts.</p><p>The <code class="literal">self</code> node should primarily be bound to the empty string, if the
<code class="literal">value</code> argument does not evaluate to a failure. There is a handy
utility meta-node, <code class="literal">!-</code>, in the <code class="literal">core</code> module, which returns the value
of its second argument if the first argument does not evaluate to a
failure. If the first argument evaluates to a failure value, it is
returned. This meta-node is registered as an infix operator thus can
be placed between its arguments.</p><p>The primary binding can thus be written as follows:</p><pre class="screen">value !- "" -&gt;
    self @ context</pre><p>If this binding results in a failure of type <code class="literal">Invalid-Integer</code>, <code class="literal">self</code>
should be bound to the constant string “Not a valid number!”. This
is achieved with the following:</p><pre class="screen">"Not a valid number!" -&gt;
    self @ context when Invalid-Integer</pre><p>Finally <code class="literal">self</code> should be bound to “Number must be greater than or
equal to 0!”, if the previous bindings resulted in a failure of type
<code class="literal">Negative-Number</code>.</p><pre class="screen">"Number must be greater than or equal to 0!" -&gt;
    self @ context when Negative-Number</pre><p>Putting it all together we have the following definition of
<code class="literal">error-message</code> re-implemented using explicit contexts:</p><p><strong>New implementation of <code class="literal">error-message</code>. </strong>
</p><pre class="screen">error-message(value) : {
    value !- "" -&gt;
        self @ context

    "Not a valid number!" -&gt;
        self @ context when Invalid-Integer

    "Number must be greater than or equal to 0!" -&gt;
        self @ context when Negative-Number
}</pre><p>
</p><p>The advantage of this implementation is that it more explicitly
conveys the intent that this is error handling logic. As such it can
be optimized more effectively, e.g. if <code class="literal">self</code> evaluates to a failure
of type <code class="literal">Negative-Number</code>, the check for whether the failure type is
<code class="literal">Invalid-Integer</code> can be skipped altogether.</p><p>An additional advantage of this implementation is that the third
binding is activated on failures of type <code class="literal">Negative-Number</code> originating
both from the first and second bindings whereas the previous
implementation only handled failures originating in <code class="literal">value</code>. In this
case it doesn’t make a difference as the second binding cannot result
in a failure of type <code class="literal">Negative-Number</code>. However this does make a
difference, in more complex error handling logic, where the handling
of an error may itself result in a new error.</p><p>This implementation does, however, have a difference from the previous
implementation in that if <code class="literal">value</code> evaluates to a failure of a type
other than <code class="literal">Invalid-Integer</code> or <code class="literal">Negative-Number</code> it returns a
failure, whereas the previous implementation returned the empty
string. In this application it doesn’t make a difference as the
arguments passed to <code class="literal">error-message</code> do not evaluate to failures of
other types.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_concise_syntax"></a>9.4. Concise Syntax</h3></div></div></div><p>Coming up with a context identifier and typing it out repeatedly can
become tiresome. The original reason for having an identifier for
explicit contexts is to distinguish them from the remaining contexts
which are implicitly created and to allow for multiple explicit
contexts. However, there is usually only a single explicit context
used for handling failures.</p><p>To shorten the syntax for binding to an explicit context, a default
identifier, such as <code class="literal">_</code> can be given to all explicit contexts which
are used only for handling failures. Alternatively, the <code class="literal">@</code> operator
can take a single argument, the node, in which case it is a shorthand
for the explicit context with identifier <code class="literal">default</code>.</p><pre class="screen"># The following:
x -&gt; y @ default

# Is equivalent to:
x -&gt; @(y)</pre><p>When the context identifier is of the form <code class="literal">when(type)</code>, that is
omitting the context identifier and leaving only the failure type, the
explicit context with identifier <code class="literal">default</code> is, once again, assumed.</p><pre class="screen"># The following:
x -&gt; y @ default when type

# Is equivalent to:
x -&gt; y @ when(type)</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s08.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s10.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>