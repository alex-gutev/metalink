== Core Module ==

(((Core Module, Standard Library)))
(((core, module, Standard Library)))

The `core` module provides the language primitives and the standard
library.

=== Literals ===

(((Literals, Core Module, Macros)))

[[macro-node-quote]]
==== Macro-Node: `'(x)` ====

(((', Core Module, Macro)))

Interprets `x` as a literal symbol rather than a node declaration.

The same symbol object is always returned for a given symbol name.

[horizontal]
`x`:: An atom node expression.

[float]
===== Pattern Matching =====

Matches the literal symbol `x`. _See <<pattern_matching>>_.


[[macro-node-c]]
==== Macro-Node: `c(x)` ====

(((c, Core Module, Macro)))

Returns `x` interpreted as a literal character.

--
- If `x` is a symbol of one character, the character is returned.
- If `x` is a string, the first character in the string is returned.
- If `x` is an integer in the range 0 -- 9, the character
  corresponding to the digit is returned.
--

[horizontal]
`x`:: The value to convert to a character.

[float]
===== Pattern Matching =====

Matches the character literal produced by the given argument. _See
<<pattern_matching>>_.


[[macro-node-ref]]
==== Macro-Node: `&(node)` ====

(((&, Core Module, Macro)))

(((&, Core Module, Macro)))

Returns the raw node object corresponding to the node with identifier
`node`. _See <<node_references>>_.

[horizontal]
`node`:: The node identifier, which can be any valid node
expression. The expression is processed in the module in which the
macro node instance occurs.


[[core-module-bindings]]
=== Bindings ===

(((Bindings, Core Module, Macros)))

[[macro-node-lbind]]
==== Macro-Node: `->(source, target)` ====

(((`->`, Core Module, Macro)))

Establishes a binding between node `source` and node `target`.

[horizontal]
`source`:: The source node.
`target`:: The target node.

NOTE: Registered as an infix operator with precedence *10* and *right*
associativity.


[[macro-node-rbind]]
==== Macro-Node: `<-(target, source)` ====

(((`<-`, Core Module, Macro)))

Establishes a binding between node `source` and node `target`.

Same as <<macro-node-lbind,`->`>> however the argument order is reversed with the first
argument being the target node and the second argument being the
source node.

[horizontal]
`target`:: The target node.
`source`:: The source node.

NOTE: Registered as an infix operator with precedence *10* and *left*
associativity.


[[macro-node-context, Macro-Node: @]]
==== Macro-Node: `@(node, context : '(default))` ====

(((@, Core Module, Macro)))

Indicates an explicit context to which bindings, involving `node` as
the 'target', should be established.

When the `@` expression appears as the target of a binding, the
binding to `node` is established in the context with identifier
`context`, _see <<_contexts>>_. The context identifier may be omitted
in which case the identifier `default` is assumed.

`context` may also be a functor of the form `when(context-id, type)`,
where `context-id` is the context identifier and `type` is a node, of
which the value is interpreted as a failure type. In this case the
binding will only be activated if the failure type, of the previous
binding in the context, is equal to `type` by <<meta-node-eq,
`=`>>. _See <<conditional_binding_fail_type>>_. If `context-id` is
omitted, that is `context` is of the form `when(type)`, the identifier
`default` is assumed.

[horizontal]
`node`:: The node.
`context`:: The context identifier, or `when` expression, _see above_.

NOTE: Registered as an infix operator with precedence *800* and *left*
associativity. The `when` symbol is also registered as an infix
operator with precedence *850* and *left* associativity.


[[macro-node-state]]
==== Macro-Node: `::(node, state)` ====

(((::, Core Module, Macro)))

When appearing as the target of a binding, a binding is established to
`node` which is only active when `node` is in the state with
identifier `state`.

`state` may also be a functor of the form `from => state`, in which
case the binding is only active when the state of `node` changes from
the state with identifier `from` to the state with identifier `to`.

_See <<node-states>> for more information._

[horizontal]
`node`:: The node.
`state`:: The state identifier or `=>` expression, _see above_.

NOTE: Registered as an infix operator with precedence *700* and *left*
associativity. The `=>` symbol is also registered as an infix operator
with precedence *750* and *left* associativity.

=== Meta-Node Definitions ===

(((Definitions, Core Module, Macros)))


[[macro-node-def]]
==== Macro-Node: `:(id(args...), body)` ====

(((:, Core Module, Macro)))

Defines a meta-node with identifier `id`, argument list `args` and
definition `body`. _See <<_meta_nodes>>_.

[horizontal]
`id`:: Meta-node identifier.
`args`:: Comma-separated list of node identifiers, to which the
meta-node arguments are bound.
`body`:: Node expression making up the definition of the meta-node. If
the definition consists of more than a single expression, it should be
enclosed in braces, _see <<_node_lists,Node Lists>>_.

NOTE: Registered as an infix operator with precedence *5* and *right*
associativity.


[[macro-node-outer]]
==== Macro-Node: `..(node)` ====

(((.., Core Module, Macro)))

Explicitly references a node defined in the enclosing scope of the
meta-node. _See <<_outer_node_references>>_.

[horizontal]
`node`:: The node identifier, which can be any valid node expression.


=== Failures ===

(((Failures, Core Module, Utilities)))

[[meta-node-fail]]
==== Meta-Node: `fail(:(type))` ====

(((fail, Core Module, Meta-Node)))

Returns a failure with a given failure type.

`type` (_Optional_):: The failure type. If not provided the failure returned has no
type.


[[meta-node-fail-type]]
==== Meta-Node: `fail-type(x)` ====

(((fail-type, Core Module, Meta-Node)))

Returns the failure type of `x`.

Returns a failure if `x` does not evaluate to a failure or evaluates
to a failure with no type.

[horizontal]
`x`:: The value of which to return the failure type.


[[meta-node-failsp]]
==== Meta-Node: `fails?(x)` ====

(((fails?, Core Module, Meta-Node)))

Returns true if `x` fails to evaluate to a value.

[horizontal]
`x`:: The value to test for failure.

[float]
===== Pattern Matching =====

Matches if the source node evaluates to a failure. If the argument `x`
is provided matches only failures of type `x` otherwise matches any
failure. _See <<pattern_matching>>_.


[[meta-node-succeedsp]]
==== Meta-Node: `?(x)` ====

(((?, Core Module, Meta-Node)))

Returns true if `x` evaluates to a value, false if `x` fails to
evaluate to a value.

[horizontal]
`x`:: The value to test for failure.


[[meta-node-fail-typep]]
==== Meta-Node: `fail-type?(x, type)` ====

(((fail-type?, Core Module, Meta-Node)))

Tests for failure with a given type.

Returns true if `x` fails with failure type equal to `type`, by
<<meta-node-eq,`=`>>. Returns false if the failure type of `x` is not
equal to `type` or `x` does not fail.

[horizontal]
`x`:: The value to check.
`type`:: The failure type.


[[meta-node-test-fail-bind]]
==== Meta-Node: `!-(test, value)` ====

(((!-, Core Module, Meta-Node)))

Returns `value` if `test` does not fail. If `test` fails, the failure
is returned.

[horizontal]
`test`:: The value which is checked for failure.
`value`:: The value which should be returned if `test` does not fail.


[[macro-node-test-fail-functor]]
==== Macro-Node: `!(functor)` ====

(((!, Core Module, Macro)))

Tests that each argument of a functor expression does not fail, before
evaluating the expression.

If at least one argument fails, then the entire functor node fails.

[horizontal]
`functor`:: The functor expression.

==== Meta-Node: `catch(try, catch, :(test))` ====

(((catch, Core Module, Meta-Node)))

Returns the value of `try` if it does not evaluate to a failure. If
`try` evaluates to a failure returns the value of `catch`.

`try`:: The value, which is returned if it does not evaluate to a
failure.

`catch`:: The value, which is returned when `try` evaluates to a
failure.

`test`:: An optional function, which is applied on the failure type of
`try`. If the function returns 'true', the value of `catch` is
returned otherwise the value of `try` is returned.

=== Builtin Failure Types ===

(((Builtin Failure Types, Core Module, Failures)))

[[node-no-value]]
==== Failure Type Node: `No-Value` ====

(((No-Value, Core Module, Node)))
(((No-Value, Core Module, Failure Type)))
(((No-Value!, Core Module, Node)))

Optional meta-nodes arguments, for which no value is provided, are
bound to a failure of this type.

Node `No-Value!` is bound to a failure of this type.


[[node-type-error]]
==== Failure Type Node: `Type-Error` ====

(((Type-Error, Core Module, Node)))
(((Type-Error, Core Module, Failure Type)))
(((Type-Error!, Core Module, Node)))

A failure of this type is returned when an argument to a meta-node is
not of the expected type.

Node `Type-Error!` is bound to a failure of this type.


==== Failure Type Node: `Index-Out-Bounds` ====

(((Index-Out-Bounds, Core Module, Node)))
(((Index-Out-Bounds, Core Module, Failure Type)))
(((Index-Out-Bounds!, Core Module, Node)))

A failure of this type is returned when attempting to access an
element at an index that is outside the bounds of the list or string.

Node `Index-Out-Bounds!` is bound to a failure of this type.


[[node-invalid-integer]]
==== Failure Type Node: `Invalid-Integer` ====

(((Invalid-Integer, Core Module, Node)))
(((Invalid-Integer, Core Module, Failure Type)))
(((Invalid-Integer!, Core Module, Node)))

A failure of this type is returned by <<meta-node-int,`int`>> when a
string, from which an integer cannot be parsed, is provided as an
argument.

Node `Invalid-Integer!` is bound to a failure of this type.

[[node-invalid-real]]
==== Failure Type Node: `Invalid-Real` ====

(((Invalid-Real, Core Module, Node)))
(((Invalid-Real, Core Module, Failure Type)))
(((Invalid-Real!, Core Module, Node)))

A failure of this type is returned by <<meta-node-int,`real`>> when a
string, from which a real number cannot be parsed, is provided as an
argument.

Node `Invalid-Real!` is bound to a failure of this type.

[[node-arity-error]]
==== Failure Type Node: `Arity-Error` ====

(((Arity-Error, Core Module, Node)))
(((Arity-Error, Core Module, Failure Type)))
(((Arity-Error!, Core Module, Node)))

A failure of this type is returned when a meta-node is invoked
indirectly, by a meta-node reference _see
<<_higher_order_meta_nodes>>_, with an incorrect number of arguments.

Node `Arity-Error!` is bound to a failure of this type.


=== Arithmetic ===

(((Arithmetic, Core Module)))

[[meta-node-plus]]
==== Meta-Node: `+(x, y)` ====

(((+, Core Module, Meta-Node)))

Computes the sum of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *100* and *left*
associativity.


[[meta-node-minus]]
==== Meta-Node: `-(x, :(y))` ====

(((-, Core Module, Meta-Node)))

Computes the difference of `x` and `y`.

If `y` is not provided, returns the negation of `x`, i.e. `x`
multiplied by `-1`.

`x`:: A number.
`y` ('Optional'):: A number.

NOTE: Registered as an infix operator with precedence *100* and *left*
associativity.


[[meta-node-multiply]]
==== Meta-Node: `*(x, y)` ====

(((*, Core Module, Meta-Node)))

Computes the product of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *200* and *left*
associativity.


[[meta-node-divide]]
==== Meta-Node: `/(x, y)` ====

(((/, Core Module, Meta-Node)))

Computes the quotient of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *200* and *left*
associativity.


[[meta-node-rem]]
==== Meta-Node: `%(x, y)` ====

(((%, Core Module, Meta-Node)))

Computes the remainder of the division of `x` by `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *200* and *left*
associativity.


=== Comparison ===

(((Comparison, Core Module)))

[[meta-node-lt]]
==== Meta-Node: `<(x, y)` ====

(((<, Core Module, Meta-Node)))

Returns true if `x` is less than `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-lte]]
==== Meta-Node: `<=(x, y)` ====

(((`<=`, Core Module, Meta-Node)))

Returns true if `x` is less than or equal to `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-gt]]
==== Meta-Node: `>(x, y)` ====

(((>, Core Module, Meta-Node)))

Returns true if `x` is greater than `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-gte]]
==== Meta-Node: `>=(x, y)` ====

(((>=, Core Module, Meta-Node)))

Returns true if `x` is greater than or equal to `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-eq]]
==== Meta-Node: `=(a, b)` ====

(((=, Core Module, Meta-Node)))

Returns true if `a` is equal to `b`.

--
- 'Numbers' are equal if they represent the same numeric
  value.
- 'Characters' are equal if they represent the same
  character.
- 'Strings' are equal if they have the same contents.
- Otherwise `a` and `b` are equal if they evaluate to the same object.
--

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-neq]]
==== Meta-Node: `!=(a, b)` ====

(((!=, Core Module, Meta-Node)))

Returns true if `a` is not equal to `b`.

_See <<meta-node-eq,`=`>> for the rules of equality_.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


=== Logical Operators ===

(((Logical Operators, Core Module)))

[[meta-node-and]]
==== Meta-Node: `and(x, y)` ====

(((and, Core Module, Meta-Node)))

Logical AND.

Returns the value of `y` if `x` evaluates to true.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *25* and *left*
associativity.

[float]
===== Pattern Matching =====

Matches if both the nested patterns in `x` and `y` match the source
node. _See <<pattern_matching>>_.


[[meta-node-or]]
==== Meta-Node: `or(x, y)` ====

(((or, Core Module, Meta-Node)))

Logical OR.

Returns the value of `x`, if it evaluates to true, otherwise returns
the value of `y`.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *20* and *left*
associativity.

[float]
===== Pattern Matching =====

Matches if at least one of the nested patterns in `x` and `y` match
the source node. Both the bindings generated by the patterns `x` and
`y` are established if the corresponding pattern condition
matches. _See <<pattern_matching>>_.

NOTE: This pattern matches even if not all its nested patterns have
matched.


[[meta-node-not]]
==== Meta-Node: `not(x)` ====

(((not, Core Module, Meta-Node)))

Logical NOT.

Returns true if `x` evaluates to false.

[horizontal]
`x`:: A value.

[float]
===== Pattern Matching =====

Matches if the nested pattern `x` does not match. The bindings
generated by `x` are not established by this pattern. _See
<<pattern_matching>>_.

NOTE: Since this binding does not establish any bindings, it is
treated as a constant pattern and may only appear nested inside other
patterns.


[[meta-node-if]]
==== Meta-Node: `if(condition, true-value, :(false-value))` ====

(((if, Core Module, Meta-Node)))

Returns `true-value` if `condition` is true otherwise returns
`false-value`.

If `false-value` is not provided, a failure is returned if `condition`
evaluates to false.

`condition`:: The condition.
`true-value`:: Value to return if `condition` is true.
`false-value` (_Optional_):: Value to return if `condition` is false. If
not provided defaults to a failure.


[[macro-node-case]]
==== Macro-Node: `case(..(clauses))` ====

(((case, Core Module, Macro)))

--------------------------------------------------
<clause> = <condition> : <value>
--------------------------------------------------

Expands to nested <<meta-node-if,`if`>> expressions.

Each argument is a `clause` is of the form `condition : value`. The
`case` expression evaluates to the `value` corresponding to the first
clause of which the `condition` node evaluates to true. The final
clause may also be of the form `value`, in which case it becomes the
default value, to which the `case` expression evaluates if the
conditions of all the other clauses evaluate to false.

[horizontal]
`clauses`:: The clauses.

.Example
--------------------------------------------------
case(
    a < b : a,
    b >= a : b
)

# Is equivalent to:

if(a < b, a, if(b >= a, b))
--------------------------------------------------

.Example with default value
--------------------------------------------------
case(
    a < b : -1,
    b > a : 1,
    0
)

# Is equivalent to:

if(a < b, -1, if(b > a, 1, 0))
--------------------------------------------------


=== Types ===

(((Type Conversions, Core Module)))
(((Type Checks, Core Module)))

[[meta-node-int]]
==== Meta-Node: `int(x)` ====

(((int, Core Module, Meta-Node)))

Converts `x` to an *integer* value.

    - If `x` is an *integer* returns `x`.
    - If `x` is a *real* returns `x` with the fractional part
      truncated.
    - If `x` is a *string*, attempts to parse an integer from
      `x`. Returns the parsed value if successful otherwise
      returns a failure of type <<node-invalid-integer,`Invalid-Integer`>>.

If `x` is neither of the above returns a failure of type
<<node-type-error,`Type-Error`>>.

[horizontal]
`x`:: The value to convert to an integer.

[float]
===== Pattern Matching =====

Matches if the source node is an *integer*, in which case `x` is
matched to the integer value. _See <<pattern_matching>>_.


[[meta-node-real]]
==== Meta-Node: `real(x)` ====

(((real, Core Module, Meta-Node)))

Converts `x` to a *real* number value.

    - If `x` is an *integer* or *real* returns `x`.
    - If `x` is a *string*, attempts to parse a real number from
      `x`. Returns the parsed value if successful otherwise
      returns a failure of type <<node-invalid-real,`Invalid-Real`>>.

If `x` is neither of the above returns a failure of type
<<node-type-error,`Type-Error`>>.

[horizontal]
`x`:: The value to convert to a real.

[float]
===== Pattern Matching =====

Matches if the source node is a *real*, in which case `x` is matched
to the real value. _See <<pattern_matching>>_.


[[meta-node-string]]
==== Meta-Node: `string(x)` ====

(((string, Core Module, Meta-Node)))

Converts `x` to a *string*.

[horizontal]
`x`:: The value to convert to a string.

[float]
===== Pattern Matching =====

Matches if the source node is a *string*, in which case `x` is matched
to the string value. _See <<pattern_matching>>_.


[[meta-node-to-int]]
==== Meta-Node: `to-int(x)` ====

(((to-int, Core Module, Meta-Node)))

Converts `x` to an *integer* value.

Same as <<meta-node-int,`int`>> however with the `target-node`
attribute set to <<meta-node-int,`int`>>. As such, in the following:

--------------------------------------------------
a -> to-int(b)
--------------------------------------------------

Node `b` is set to the value of `a` converted to an integer.

[horizontal]
`x`:: The value to convert.


[[meta-node-to-real]]
==== Meta-Node: `to-real(x)` ====

(((to-real, Core Module, Meta-Node)))

Converts `x` to an *real* number value.

Same as <<meta-node-real,`real`>> however with the `target-node`
attribute set to <<meta-node-real,`real`>>. As such, in the following:

--------------------------------------------------
a -> to-real(b)
--------------------------------------------------

Node `b` is set to the value of `a` converted to a real number.

[horizontal]
`x`:: The value to convert.


[[meta-node-to-string]]
==== Meta-Node: `to-string(x)` ====

(((to-string, Core Module, Meta-Node)))

Converts `x` to an *integer* value.

Same as <<meta-node-string,`string`>> however with the `target-node`
attribute set to <<meta-node-string,`string`>>. As such, in the following:

--------------------------------------------------
a -> to-string(b)
--------------------------------------------------

Node `b` is set to the value of `a` converted to a string.

[horizontal]
`x`:: The value to convert.


[[meta-node-intp]]
==== Meta-Node: `int?(x)` ====

(((int?, Core Module, Meta-Node)))

Returns true if `x` is an *integer*.

[horizontal]
`x`:: The value to test.


[[meta-node-realp]]
==== Meta-Node: `real?(x)` ====

(((real?, Core Module, Meta-Node)))

Returns true if `x` is a *real*.

[horizontal]
`x`:: The value to test.


[[meta-node-stringp]]
==== Meta-Node: `string?(x)` ====

(((string?, Core Module, Meta-Node)))

Returns true if `x` is a *string*.

[horizontal]
`x`:: The value to test.


[[meta-node-infp]]
==== Meta-Node: `inf?(x)` ====

(((inf?, Core Module, Meta-Node)))

Returns true if `x` is either positive or negative infinity.

[horizontal]
`x`:: The value to test.


[[meta-node-nanp]]
==== Meta-Node: `NaN?(x)` ====

(((NaN?, Core Module, Meta-Node)))

Returns true if `x` is a *NaN* value.

[horizontal]
`x`:: The value to test.


=== Lists ===

(((Lists, Core Module)))

Lists are represented by a special `cons` type, in which the 'head'
stores the first element of the list and the 'tail' stores the list of
remaining elements. Neither the 'head' nor the 'tail' are evaluated
until they are actually referenced and used.

The end of list is represented by a failure of type `Empty`, see
<<node-Empty, `Empty`>>.


[[meta-node-cons]]
==== Meta-Node: `cons(head, tail)` ====

(((cons, Core Module, Meta-Node)))

Creates a list with the `head` as the first element and `tail` as
the list of remaining elements.

[horizontal]
`head`:: The first element of the list.
`tail`:: The list containing the remaining elements after the first.

[float]
===== Pattern Matching =====

Matches if the source node is a non-empty list, in which case `head`
is matched to the 'head' of the list and tail is matched to the 'tail'
of the list. _See <<pattern_matching>>_.


[[meta-node-head]]
==== Meta-Node: head(list) ====

(((head, Core Module, Meta-Node)))

Returns the 'head' (first element) of a list.

If `list` is not a list returns a failure value.

[horizontal]
`list`:: The list.


[[meta-node-tail]]
==== Meta-Node: `tail(list)` ====

(((tail, Core Module, Meta-Node)))

Returns the 'tail', the list containing the elements after the first
element, of a list.

If `list` is not a list returns a failure value.

[horizontal]
`list`:: The list.


[[meta-node-consp]]
==== Meta-Node: `cons?(thing)` ====

(((cons?, Core Module, Meta-Node)))

Returns true if `thing` is a list of at least one element, false
otherwise.

NOTE: Does not return true if `thing` is an empty list.

[horizontal]
`list`:: The list.


[[node-Empty]]
==== Failure Type Node: Empty ====

(((Empty, Core Module, Node)))
(((Empty, Core Module, Failure Type)))
(((Empty!, Core Module, Node)))

Failure type indicating an empty list.

Node `Empty!` is bound to a failure of this type.


[[meta-node-list]]
==== Meta-Node: `list(..(xs))` ====

(((list, Core Module, Meta-Node)))

Creates a list with elements `xs`.

[horizontal]
`xs`:: The list elements.

[float]
===== Pattern Matching =====

Matches if the source node is a list of the same size as `xs`, in
which case each argument in `xs` is matched to the corresponding list
element. _See <<pattern_matching>>_.


[[meta-node-list-star]]
==== Meta-Node: `list*(..(xs))` ====

(((list*, Core Module, Meta-Node)))

Creates a list containing, as elements, all the arguments in `xs`
excluding the last. The last argument in `xs` is treated as a list
containing the remaining elements.

[horizontal]
`xs`:: The list elements, with the last argument being the list
containing the remaining elements.

[float]
===== Pattern Matching =====

Matches if the source node is a list of at least one less elements
that the number of elements in `xs`. The arguments, excluding the
last, are matched to the corresponding elements in the list with the
last argument being matched to the remaining list elements. _See
<<pattern_matching>>_.


[[meta-node-list-bang]]
==== Meta-Node: `list!(..(xs))` ====

(((list!, Core Module, Meta-Node)))

Creates a list containing, as elements, all the arguments in `xs`.

Unlike `list`, if at least one of `xs` fails to evaluate to a value, a
failure is returned.

[horizontal]
`xs`:: The list elements.


[[meta-node-nth]]
==== Meta-Node: `nth(list, n)` ====

(((nth, Core Module, Meta-Node)))

Retrieves the element of a list at a particular index.

Returns a failure of type <<node-Empty, `Empty`>> if `n` is
greater than the number of elements in `list`.

[horizontal]
`list`:: The list.
`n`:: The index of the element to retrieved.


[[meta-node-append]]
==== Meta-Node: `append(list1, list2)` ====

(((append, Core Module, Meta-Node)))

Returns a list containing the elements of `list2` appended to
`list1`.

[horizontal]
`list1`:: The initial list.
`list2`:: The list which is appended onto `list1`.


[[meta-node-foldl1]]
==== Meta-Node: `foldl'(x, f, list)` ====

(((foldl', Core Module, Meta-Node)))

Folds a list to a single value, starting from the first element.

The function `f` is first applied on `x` and the <<meta-node-head, 'head'>> of
`list`. Subsequently, `f` is applied on the result of the previous
application and the next element of `list`, until the end of `list` is
reached.

[horizontal]
`x`:: Initial first argument to `f`.
`f`:: Function of two arguments.
`list`:: List to fold.


[[meta-node-foldl]]
==== Meta-Node: `foldl(f, list)` ====

(((fold, Core Module, Meta-Node)))

Folds a list to a single value, starting from the first element.

Same as <<meta-node-foldl1,`foldl'`>> except the <<meta-node-head, 'head'>> of `list` is
used as the initial first argument to the fold function `f`.

[horizontal]
`f`:: Function of two arguments.
`list`:: List to fold.


[[meta-node-foldr]]
==== Meta-Node: `foldr(f, list, :(x))` ====

(((foldr, Core Module, Meta-Node)))

Folds a list to a single value, starting from the last element.

`f` is first applied on the last element of `list` and the value of
`x`. If the `x` argument is not provided or `x` evaluates to a failure
of type <<node-no-value, `No-Value`>>, `f` is first applied on the
last two elements of `list`. Subsequently `f` is applied on the
previous element of `list` and the result of the previous application,
until the 'head' of list `list` is reached.

If `list` only has a single element and `x` is not provided, the
element is returned as is. If `l` is empty and `x` is provided, `x` is
returned as is.


`f`:: Function of two arguments.
`list`:: List to fold.
`x` (_Optional_):: Second argument to the application of `f` on the
last element of `list`.


[[meta-node-map]]
==== Meta-Node: `map(f, list)` ====

(((map, Core Module, Meta-Node)))

Applies a function on each element of a list.

Returns a list containing the result of applying `f` on each element
of `list` in turn.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


[[meta-node-filter]]
==== Meta-Node: `filter(f, list)` ====

(((filter, Core Module, Meta-Node)))

Filters elements from a list.

Returns a list containing only the elements of `list` for which the
function `f` returns true.

[horizontal]
`f`:: Function of one argument, which should return true if the
argument should be retained in the list or false if it should be
removed.

`list`:: The list to filter.


[[meta-node-everyp]]
==== Meta-Node: `every?(f, list)` ====

(((every?, Core Module, Meta-Node)))

Returns true if `f` returns true for every element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


[[meta-node-somep]]
==== Meta-Node: `some?(f, list)` ====

(((some?, Core Module, Meta-Node)))

Returns true if `f` returns true for at least one element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


[[meta-node-not-anyp]]
==== Meta-Node: `not-any?(f, list)` ====

(((not-any?, Core Module, Meta-Node)))

Returns true if `f` returns false for every element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


[[meta-node-not-everyp]]
==== Meta-Node: `not-every?(f, list)` ====

(((not-every?, Core Module, Meta-Node)))

Returns true if `f` returns false for at least one element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


=== Strings ===

(((Strings, Core Module)))

[[meta-node-string-at]]
==== Meta-Node: `string-at(string, index)` ====

(((string-at, Core Module, Meta-Node)))

Returns the character at a given index in the string.

If the index is greater than the number of characters in this string,
returns a failure.

[horizontal]
`string`:: The string.
`index`:: The index of the character.


[[meta-node-string-concat]]
==== Meta-Node: `string-concat(string, str1, str2)` ====

(((string-concat, Core Module, Meta-Node)))

Concatenates `str2` to the end of `str1`.

[horizontal]
`str1`:: The first string.
`str2`:: The string which is concatenated to `str1`.



[[meta-node-string-to-list]]
==== Meta-Node: `string->list(string)` ====

(((`string->list`, Core Module, Meta-Node)))

Returns a list containing the characters in a string.

[horizontal]
`string`:: The string.


[[meta-node-list-to-string]]
==== Meta-Node: `list->string(list)` ====

(((`list->string`, Core Module, Meta-Node)))

Returns a string containing the concatenation of the elements in a list.

Each element of `list` is converted to a string and concatenated to
the result string.

[horizontal]
`list`:: List of elements to concatenate.


[[meta-node-format]]
==== Meta-Node: `format(string, ..(args))` ====

(((format, Core Module, Meta-Node)))

Creates a formatted string, in which placeholders are replaced by the
arguments in `args`.

The sequence `%s` designates a placeholder which is to be replaced by
an argument. The first placeholder is replaced by the first argument,
the second with the second argument and so on. Each argument is
converted to a string prior to being substituted into the result
string.

The sequence `%%` designates a literal `%` character and is thus
replaced with a `%`.

[horizontal]
`string`:: The format string.
`args`:: The arguments to substitute into the string.


=== Dictionaries ===

==== Meta-Node: `member(dict, key)` ====

Retrieves the value of an entry in a dictionary.

[horizontal]
`dict`:: The dictionary.
`key`:: The entry key.


=== Functions ===

==== Meta-Node: `apply(f, ..(xs))`

(((apply, Core Module, Meta-Node)))

Applies a function on an argument list.

The argument list, on which `f` is applied consist of each argument of
`xs`, excluding the last, followed by each element of the last
argument of `xs`.

[horizontal]
`f`:: The function to apply.
`xs`:: The arguments to apply `f` on.

CAUTION: If `f` is not a function or the last argument of `xs` is not
a list, a failure of type <<node-type-error, `Type-Error`>>, is
returned.


=== Introspection ===

(((Introspection Utilities, Core Module)))

The `core/introspection` module provides utility meta-nodes for
introspecting the nodes comprising a program. These meta-nodes may
only be used within macro nodes, during macro expansion, as runtime
definitions are not available.

[[meta-node-nodep]]
==== Meta-Node: `node?(thing)` ====

(((node?, Core Module, Meta-Node)))

Returns true if `thing` is a node object.

[horizontal]
`thing`:: The thing to check whether it is a node.


==== Meta-Node: `find-node(node, :(module))` ====

(((find-node, Core Module, Meta-Node)))

Looks-up a node in a module.

Returns the node object or a failure if no node is found.

`node`:: The node to lookup, which can be any node expression.
`module` ('Optional'):: The module in which to look-up the
node. Defaults to the current module, set by the last `:module`
declaration that is processed.

NOTE: Currently there is no way to retrieve a module object, thus the
`module` argument is not used. This functionality will be added in a
future release.


==== Meta-Node: `get-attribute(node, attribute)` ====

(((get-attribute, Core Module, Meta-Node)))

Retrieves the value of an attribute of a node.

Returns a failure if the attribute is not set.

[horizontal]
`node`:: The node object.
`attribute`:: The attribute identifier.


[[pattern_matching,Pattern Matching]]
=== Pattern Matching ===

(((Pattern Matching, Core Module)))
(((Functor Patterns, Core Module, Pattern Matching)))

Pattern matching is provided by the core module in the form of
bindings involving the meta-node instance, which is to be matched, as
the target. The binding succeeds if the pattern matches, otherwise it
fails.

A meta-node which supports pattern matching, has a `target-node` or
`target-transform`, _see <<_instances_as_targets>>_, such that when an
instance of the meta-node appears as the target of a binding, the
argument nodes are bound to the values, required in order for the
meta-node to return a value that is equivalent to the value of the
source node. When there are such values, the pattern is said to have
'matched'. If there is no possible value for at least one argument
node, all argument nodes should evaluate to failures of type
<<match-fail, `Match-Fail`>>. In this case the pattern has not
'matched'

.Example
--------------------------------------------------
x -> int(y)
--------------------------------------------------

In the example, above, `y` is bound to the value of `x` if it is an
integer, otherwise `y` evaluates to a failure. There is no argument
which will result in `int` returning a non-integer value thus if the
source node, `x`, is not an integer the argument node, `y`, is bound
to a failure. Since `int` returns the value of its argument directly,
when it is an integer, the argument node is simply bound to the source
node.

.Example
--------------------------------------------------
x -> list(y, z)
--------------------------------------------------

In the example, above, `y` is bound to the first element of `x` and
`z` is bound to the second element of `x` if `x` is a list of two
elements. These bindings will result in a list, equivalent to `x`,
being produced when `y` and `z` are passed as arguments to the `list`
meta-node.

==== Nested Patterns ====

(((Nested Patterns, Core Module, Pattern Matching)))

Patterns may be nested, that is an argument to a meta-node instance is
itself a meta-node instance of which the operator meta-node supports
pattern matching. When the arguments contain one or more nested
patterns, the bindings to the argument nodes should only succeed if
all nested patterns 'match'.

.Example
--------------------------------------------------
x -> list(int(y), z)
--------------------------------------------------

The example, above, is similar to the previous example except with the
additional condition that the first element of `x` should also be an
integer. That is `y` is bound to the first element of `x` and `z` to
the second element of `x` if `x` is a list of two elements of which
the first element is an integer.

When `_` appears nested inside a pattern it matches anything and does
not establish any bindings. This is used to indicate that the value
for a particular argument is unimportant.

.Example
--------------------------------------------------
x -> list(_, y)
--------------------------------------------------

In the example, above, `y` is bound to the second element of `x` if it
is a list of two elements. The value of the first element of `x` is
ignored completely.


==== Constant Patterns ====

(((Constant Patterns, Core Module, Pattern Matching)))

Constant patterns comprise a constant value as opposed to a
node. These patterns 'match' when the source node is equal, by
<<meta-node-eq, `=`>>, to the constant value. Constant patterns do not
result in any bindings being established however they do affect the
condition of the pattern in which they are nested.

IMPORTANT: Constant patterns may only be used when nested inside a
non-constant pattern.

Constant values include any literal constants, such as numbers,
strings as well as character literals, produced by the <<macro-node-c,
`c`>> macro, and literal symbols, produced by the
<<macro-node-quote,`'`>> macro.

.Example
--------------------------------------------------
x -> list(1, y, z)
--------------------------------------------------

In the example, above, `y` is bound to the second element of `x` and
`z` to the third element of `x` if `x` is a list of three elements of
which the first element is equal to `1`.

The following are examples of invalid uses of constant patterns:

.Examples: Invalid use of Constant Patterns
--------------------------------------------------
# Invalid as the pattern is not nested
x -> 1

# Invalid as at least one argument should not be a constant.
x -> list(1, 2)
--------------------------------------------------

CAUTION: Functor nodes, of which the arguments are all constants, such
as `1 + 1`, are only treated as constant patterns if the meta-node
supports pattern matching. In this case the `+` meta-node does not
support pattern matching, thus `1 + 1` is currently not treated as a
constant pattern.


[[matchers, Matchers]]
==== Matchers ====

(((matcher, Attribute, Pattern Matching)))
(((Pattern Object, Core Module, Pattern Matching)))

The `matcher` node attribute stores a meta-node which is called to
construct the pattern for a given list of arguments. The 'matcher'
meta-node is called with two arguments: the place to be matched, which
should become the 'source' node of any bindings established by the
pattern, and the pattern 'functor' expression itself (including the
operator). The meta-node should return a `Pattern` object, which is a
dictionary containing the following entries:

`condition`:: The node expression which evaluates to true if the
pattern matches. This should include the conditions of the argument
nodes if they are patterns themselves.

`bindings`:: List of bindings established by the pattern. If there are
no bindings established by the pattern, then this entry should be set
to the empty list, _see <<node-Empty, `Empty`>>_.
+
--
IMPORTANT: The bindings should not be conditioned on `condition` as
they will be conditioned later when the node declarations for the
entire pattern (including the parent patterns) is constructed. _See
<<conditional_bindings>>_.
--

TIP: Pattern objects may be created with the <<meta-node-Pattern,
`Pattern`>> meta-node.

All bindings, established by a pattern, should be established in an
explicit context with identifier `match`, which is activated only on
failures with type <<match-fail,`&(Match-Fail)`>>. This allows
multiple patterns to be specified on a single node, with the node
being set to the value corresponding to the binding of the first
pattern that 'matches'.

.Example: Multiple Patterns
--------------------------------------------------
x -> int(y)
x -> list(int(y))
x -> list("x", int(y))
--------------------------------------------------

The example above contains multiple patterns involving a single node
`y`.

`y` is bound to:

. the value of `x` if it is an integer, or
. the first element of `x` if it is a list of one element, which is an
integer, or
. the second element of `x` if it is a list of two elements, with the
first element being the string value `"x"` and the second element
being an integer.


The following meta-nodes in the `core` module all have a matcher and
may thus appear within patterns.

 - <<macro-node-quote, `'`>>
 - <<macro-node-c, `c`>>
 - <<meta-node-failsp, `fails?`>>
 - <<meta-node-and, `and`>>
 - <<meta-node-or, `or`>>
 - <<meta-node-not, `not`>>
 - <<meta-node-int, `int`>>
 - <<meta-node-real, `real`>>
 - <<meta-node-string, `string`>>
 - <<meta-node-cons, `cons`>>
 - <<meta-node-list, `list`>>
 - <<meta-node-list-star, `list*`>>


=== Module: core/patterns ===

(((Pattern Matching Utilities, Core Module, Pattern Matching)))

This module contains utilities for creating and processing patterns.


[[meta-node-Pattern]]
==== Meta-Node: `Pattern(condition, :(binding))` ====

(((Pattern, Core Module, Meta-Node)))

Creates a `Pattern` object. _See <<matchers>>_

`condition`:: The node expression which evaluates to true if the
pattern matches.

`binding (Optional)`:: List of binding expressions of the bindings
established by the pattern. Defaults to the empty list if not
provided.


[[meta-node-get-matcher]]
==== Meta-Node: `get-matcher(node)` ====

(((get-matcher, Core Module, Meta-Node)))

Returns the 'matcher' function, stored in the `matcher` attribute of a
node.

Returns a failure if the node's `matcher` attribute is not set.

[horizontal]
`node`:: The node object of which to retrieve the 'matcher'.


[[meta-node-make-pattern]]
==== Meta-Node: `make-pattern(place, pattern)` ====

(((make-pattern, Core Module, Meta-Node)))

Creates the `Pattern` object for a pattern expression.

NOTE: Can be used for any pattern, including constant patterns.

`place`:: The place which should be matched to the pattern, i.e. the
source node of the bindings established by the pattern.

`pattern`:: The pattern expression.

NOTE: If `pattern` is a functor expression of which the operator is
not a `meta-node` with a `matcher`, a `Pattern` with a single binding
`place -> pattern`, and no `condition` is returned.


[[meta-node-combine-conditions]]
==== Meta-Node: `combine-conditions(c1, c2)` ====

(((combine-conditions, Core Module, Meta-Node)))

Returns an expression which is the conjunction of two expressions, by
<<meta-node-and, `and`>>.

`c1`:: The first condition, on the left hand side of the `and`.
`c2`:: The second condition, on the right hand side of the `and`.

If `c1` evaluates to a failure, returns `c2`. If `c2` evaluates to a
failure, returns `c1`.

TIP: This is useful for creating a condition which combines the
conditions of multiple argument nodes.


[[meta-node-conditionalize-bindings]]
==== Meta-Node: conditionalize-bindings(condition, bindings) ====

(((conditionalize-bindings, Core Module, Meta-Node)))

Returns a list where each binding in `bindings` is conditioned on
`condition`. _See <<conditional_bindings>>_.

`condition`:: The condition on which to condition the bindings.
`bindings`:: List of bindings to condition.

[[match-fail]]
==== Failure Type Node: Match-Fail ====

(((Match-Fail, Core Module, Failure Type)))
(((Match-Fail, Core Module, Node)))
(((Match-Fail!, Core Module, Node)))

Failure type indicating that a pattern failed to match.

Node `Match-Fail!` is bound to a failure of this type.


==== Meta-Node: fail-match(condition) ====

(((fail-match, Core Module, Meta-Node)))

If `condition` evaluates to false or to a failure, returns a failure
of type <<match-fail,`Match-Fail`>>, otherwise returns 'true'.

`condition`:: The pattern condition.


==== Meta-Node: make-match-bind(src, target) ====

(((make-match-bind, Core Module, Meta-Node)))

Generates a binding `src -> target`, with `target` in the `match`
context which is activated on failures of type
<<match-fail,`Match-Fail`>>.

`src`:: The source of the binding.
`target`:: The target of the binding.


[[meta-node-make-pattern-declarations]]
==== Meta-Node: make-pattern-declarations(pattern) ====

(((make-pattern-declarations, Core Module, Meta-Node)))

Creates the node declarations implementing a pattern.

Returns a single node declaration.

`pattern`:: The `Pattern` object for which to create the declarations.

TIP: The declaration returned by this meta-node is a suitable return
value for a `target-transform` function. _See <<_instances_as_targets>>_.


=== Operator Table ===

(((Operator Table, Core Module)))

[cols="<,>,>", options="header"]
|====================
| Operator | Precedence | Associativity

| `.`       | 1000       | left
| `when`    | 850        | left
| `@`       | 800        | left
| `=>`      | 750        | left
| `::`      | 700        | left
| `*`       | 200        | left
| `/`       | 200        | left
| `+`       | 100        | left
| `-`       | 100        | left
| `<`       | 50         | left
| `<=`      | 50         | left
| `>`       | 50         | left
| `>=`      | 50         | left
| `=`       | 50         | left
| `!=`      | 50         | left
| `and`     | 25         | left
| `or`      | 20         | left
| `!-`      | 15         | right
| `->`      | 10         | right
| `<-`      | 10         | left
| `:`       | 5          | right
|====================
