== Core Module ==

The `core` module provides the language primitives and the standard
library.

=== Literals ===

[id="macro-node-'"]
.Macro-Node: `'(x)`
--
Interprets `x` as a literal symbol rather than a node declaration.

The same symbol object is returned for a given symbol name.

[horizontal]
`x`:: An atom node declaration.
--

[[macro-node-c]]
.Macro-Node: `c(x)`
--
Returns `x` interpreted as a literal character.

--
- If `x` is a symbol of one character, the character is returned.
- If `x` is a string, the first character in the string is returned.
- If `x` is an integer in the range 0 -- 9, the character
  corresponding to the digit is returned.
--

[horizontal]
`x`:: The value to convert to a character.
--

[id="macro-node-&"]
.Macro-Node: `&(id)`
--
Returns the raw node object corresponding to the node with identifier
`id`.

[horizontal]
`id`:: The node identifier, which can be any valid node
declaration. The declaration is processed in the module in which the
macro node instance occurs.
--

=== Bindings ===

[id="macro-node->"]
.Macro-Node: `->(source, target)`
--
Establishes a binding between node `source` and node `target`.

[horizontal]
`source`:: The source node.
`target`:: The target node.

NOTE: Registered as an infix operator with precedence *10* and *right*
associativity.
--

[id="macro-node-<-"]
.Macro-Node: `<-(target, source)`
--
Establishes a binding between node `source` and node `target`.

Same as `->` however the argument order is reversed with the first
argument being the target node and the second argument being the
source node.

[horizontal]
`target`:: The target node.
`source`:: The source node.

NOTE: Registered as an infix operator with precedence *10* and *left*
associativity.
--

[id="macro-node-@"]
.Macro-Node: `@(node, context)`
--
Indicates an explicit context to which bindings, involving `node` as
the 'target', should be established.

When the `@` declaration appears as the target of a binding, the
binding to `node` is established in the context with identifier
`context`, _see <<_contexts, Contexts>>_.

`context` may also be a functor of the form `catch(context-id, type)`,
where `context-id` is the context identifier and `type` is a node, of
which the value is interpreted as a failure type. In this case the
binding will only be activated if the failure type, of the previous
binding in the context, is equal to `type` by <<meta-node-=,
`=`>>. _See <<_conditionally_active_bindings_based_on_failure_type,
Conditionally Active Bindings based on Failure Type>>_.

[horizontal]
`node`:: The node.
`context`:: The context identifier, or catch expression, _see above_.

NOTE: Registered as an infix operator with precedence *800* and *left*
associativity. The `catch` symbol is also registered as an infix
operator with precedence *850* and *left* associativity.
--

=== Meta-Node Definitions ===

[id="macro-node-:"]
.Macro-Node: `:(id(args...), body)`
--
Defines a meta-node with identifier `id`, argument list `args` and
definition `body`.

[horizontal]
`id`:: Meta-node identifier.
`args`:: Comma-separated list of node identifiers, to which the
meta-node arguments are bound.
`body`:: Node declaration making up the definition of the
meta-node. If the definition consists of more than a single
declaration, it should be enclosed in braces, _see <<_node_lists,Node Lists>>_.

NOTE: Registered as an infix operator with precedence *5* and *right*
associativity.
--

[id="macro-node-.."]
.Macro-Node: `..(node)`
--
Explicitly references a node defined in the enclosing scope of the
meta-node. _See <<_outer_node_references, Outer Node References>>_.

[horizontal]
`node`:: The node identifier, which can be any valid node declaration.
--

=== Failures ===

[[meta-node-fail]]
.Meta-Node: `fail(:(type))`
--
Returns a failure with a given failure type.

`type` (_Optional_):: The failure type. If not provided the failure returned has no
type.
--

[[meta-node-fail-type]]
.Meta-Node: `fail-type(x)`
--
Returns the failure type of `x`.

If `x` does not evaluate to a failure or evaluates to a failure with
no type, returns a failure.

[horizontal]
`x`:: The value of which to return the failure type.
--

[id="meta-node-fails?"]
.Meta-Node: `fails?(x)`
--
Returns true if `x` fails to evaluate to a value.

[horizontal]
`x`:: The value to test for failure.
--

[id="meta-node-?"]
.Meta-Node: `?(x)`
--
Returns true if `x` evaluates to a value, false if `x` fails to
evaluate to a value.

[horizontal]
`x`:: The value to test for failure.
--

[id="meta-node-fail-type?"]
.Meta-Node: `fail-type?(x, type)`
--
Tests for failure with a given type.

Returns true if `x` fails with failure type equal to `type`, by
<<meta-node-=,`=`>>. Returns false if the failure type of `x` is not
equal to `type` or `x` does not fail.

[horizontal]
`x`:: The value to check.
`type`:: The failure type.
--

[id="meta-node-!-"]
.Meta-Node: `!-(test, value)`
--
Returns `value` if `test` does not fail. If `test` fails, the failure
is returned.

[horizontal]
`test`:: The value which is checked for failure.
`value`:: The value which should be returned if `test` does not fail.
--

[id="macro-node-!"]
.Macro-Node: `!(functor)`
--
Tests that each argument of a functor expression does not fail, before
evaluating the expression.

If at least one argument fails, then the entire functor expression
fails.

[horizontal]
`functor`:: The functor expression.
--

=== Arithmetic ===

[id="meta-node-+"]
.Meta-Node: `+(x, y)`
--
Computes the sum of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *100* and *left*
associativity.
--

[id="meta-node--"]
.Meta-Node: `-(x, y)`
--
Computes the difference of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *100* and *left*
associativity.
--

[id="meta-node-*"]
.Meta-Node: `*(x, y)`
--
Computes the product of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *200* and *left*
associativity.
--

[id="meta-node-/"]
.Meta-Node: `/(x, y)`
--
Computes the quotient of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *200* and *left*
associativity.
--

=== Comparison ===

[id="meta-node-<"]
.Meta-Node: `<(x, y)`
--
Returns true if `x` is less than `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.
--

[id="meta-node-<="]
.Meta-Node: `<=(x, y)`
--
Returns true if `x` is less than or equal to `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.
--

[id="meta-node->"]
.Meta-Node: `>(x, y)`
--
Returns true if `x` is greater than `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.
--

[id="meta-node->="]
.Meta-Node: `>=(x, y)`
--
Returns true if `x` is greater than or equal to `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.
--

[id="meta-node-="]
.Meta-Node: `=(a, b)`
--
Returns true if `a` is equal to `b`.

--
- 'Numbers' are equal if they represent the same numeric
  value.
- 'Characters' are equal if they represent the same
  character.
- 'Strings' are equal if they have the same contents.
- Otherwise `a` and `b` are equal if they evaluate to the same object.
--

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.
--

[id="meta-node-!="]
.Meta-Node: `!=(a, b)`
--
Returns true if `a` is not equal to `b`.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.
--


=== Logical Operators ===

[[meta-node-and]]
.Meta-Node: `and(x, y)`
--
Logical AND.

Returns the value of `y` if `x` evaluates to true.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *25* and *left*
associativity.
--

[[meta-node-or]]
.Meta-Node: `or(x, y)`
--
Logical OR.

Returns the value of `x`, if it evaluates to true, otherwise returns
the value of `y`.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *20* and *left*
associativity.
--

[[meta-node-not]]
.Meta-Node: `not(x)`
--
Logical NOT.

Returns true if `x` evaluates to false.

[horizontal]
`x`:: A value.
--

[[meta-node-if]]
.Meta-Node: `if(condition, true-value, :(false-value))`
--

Returns `true-value` if `condition` is true otherwise returns
`false-value`.

If `false-value` is not provided, a failure is returned if `condition`
evaluates to false.

[horizontal]
`condition`:: The condition.
`true-value`:: Value to return if `condition` is true.
`false-value` (_Optional_):: Value to return if `condition` is false. If
not provided defaults to a failure.
--

[[macro-node-case]]
.Macro-Node: `case(..(clauses))`
--

--------------------------------------------------
<clause> = <condition> : <value>
--------------------------------------------------

Expands to nested <<meta-node-if,`if`>> expressions.

Each argument is a `clause` is of the form `condition : value`. The
`case` expression evaluates to the `value` corresponding to the first
clause of which the `condition` evaluates to true. The final clause
may also simply be of the form `value`, in which case it becomes the
default value, to which the `case` expression evaluates if the
`condition`'s of all clauses evaluate to false.

[horizontal]
`clauses`:: The clauses.

.Example
--------------------------------------------------
case(
    a < b : a,
    b >= a : b
)

# Is equivalent to:

if(a < b, a, if(b >= a, b))
--------------------------------------------------

.Example with default value
--------------------------------------------------
case(
    a < b : -1,
    b > a : 1,
    0
)

# Is equivalent to:

if(a < b, -1, if(b > a, 1, 0))
--------------------------------------------------
--

=== Types ===

[[meta-node-int]]
.Meta-Node: `int(x)`
--
Converts `x` to an *integer* value.

    - If `x` is an *integer* returns `x`.
    - If `x` is a *real* returns `x` with the fractional part
      truncated.
    - If `x` is a *string*, attempts to parse an integer from
      `x`. Returns the parsed value if successful otherwise
      returns a failure.

If `x` is neither of the above returns a failure.

[horizontal]
`x`:: The value to convert to an integer.
--

[[meta-node-real]]
.Meta-Node: `real(x)`
--
Converts `x` to a *real* number value.

    - If `x` is an *integer* or *real* returns `x`.
    - If `x` is a *string*, attempts to parse a real number from
      `x`. Returns the parsed value if successful otherwise
      returns a failure.

If `x` is neither of the above returns a failure.

[horizontal]
`x`:: The value to convert to a real.
--

[[meta-node-string]]
.Meta-Node: `string(x)`
--
Converts `x` to a *string*.

[horizontal]
`x`:: The value to convert to a string.
--

[id="meta-node-int?"]
.Meta-Node: `int?(x)`
--
Returns true if `x` is an *integer*.

[horizontal]
`x`:: The value to test.
--

[id="meta-node-real?"]
.Meta-Node: `real?(x)`
--
Returns true if `x` is a *real*.

[horizontal]
`x`:: The value to test.
--

[id="meta-node-string?"]
.Meta-Node: `string?(x)`
--
Returns true if `x` is a *string*.

[horizontal]
`x`:: The value to test.
--

[id="meta-node-inf?"]
.Meta-Node: `inf?(x)`
--
Returns true if `x` is either positive or negative infinity.

[horizontal]
`x`:: The value to test.
--

[id="meta-node-NaN?"]
.Meta-Node: `NaN?(x)`
--
Returns true if `x` is a *NaN* value.

[horizontal]
`x`:: The value to test.
--

=== Lists ===

[[meta-node-cons]]
.Meta-Node: `cons(head, tail)`
--
Creates a list with the `head` as the first element and `tail` as
the list of remaining elements.

[horizontal]
`head`:: The first element of the list.
`tail`:: The list containing the remaining elements after the first.
--

[[meta-node-head]]
.Meta-Node: head(list)
--
Returns the 'head' (first element) of a list.

If `list` is not a list returns a failure value.

[horizontal]
`list`:: The list.
--

[[meta-node-tail]]
.Meta-Node: `tail(list)`
--
Returns the 'tail', the list containing the elements after the first
element, of a list.

If `list` is not a list returns a failure value.

[horizontal]
`list`:: The list.
--

[id="meta-node-cons?"]
.Meta-Node: `cons?(thing)`
--
Returns true if `thing` is a list of at least one element, false
otherwise.

NOTE: Does not return true if `thing` is an empty list.

[horizontal]
`list`:: The list.
--

[[meta-node-Empty]]
.Meta-Node: Empty()
--
Returns a failure with type indicating an empty list.

NOTE: The failure type is simply `&(Empty)`, _see <<_node_references,
Node References>>_.
--

[[meta-node-list]]
.Meta-Node: `list(..(xs))`
--
Creates a list with elements `xs`.

[horizontal]
`xs`:: The list elements.
--

[id="meta-node-list*"]
.Meta-Node: `list*(..(xs))`
--
Creates a list containing, as elements, all the arguments in `xs`
excluding the last. The last argument in `xs` is treated as a list
containing the remaining elements.

`xs`:: The list elements, with the last argument being the list
containing the remaining elements.
--

[id="meta-node-list!"]
.Meta-Node: `list!(..(xs))`
--
Creates a list containing, as elements, all the arguments in `xs`.

Unlike `list`, if at least one of `xs` fails to evaluate to a value, a
failure is returned.

[horizontal]
`xs`:: The list elements.
--

[[meta-node-nth]]
.Meta-Node: `nth(list, n)`
--
Retrieves the element of a list at a particular index.

Returns a failure of type <<meta-node-Empty, `Empty`>> if `n` is
greater than the number of elements in `list`.

[horizontal]
`list`:: The list.
`n`:: The index of the element to retrieved.
--

[[meta-node-append]]
.Meta-Node: `append(list1, list2)`
--
Returns a list containing the elements of `list2` appended to
`list1`.

[horizontal]
`list1`:: The initial list.
`list2`:: The list which is appended onto `list1`.
--

[id="meta-node-foldl'"]
.Meta-Node: `foldl'(x, f, list)`
--
Folds a list to a single value, starting from the first element.

The function `f` is first applied on `x` and the <<meta-node-head, 'head'>> of
`list`. Subsequently, `f` is applied on the result of the previous
application and the next element of `list`, until the end of `list` is
reached.

[horizontal]
`x`:: Initial first argument to `f`.
`f`:: Function of two arguments.
`list`:: List to fold.
--

[[meta-node-foldl]]
.Meta-Node: `foldl(f, list)`
--
Folds a list to a single value, starting from the first element.

Same as <<meta-node-foldl',`foldl'`>> except the <<meta-node-head, 'head'>> of `list` is
used as the initial first argument to the fold function `f`.

[horizontal]
`f`:: Function of two arguments.
`list`:: List to fold.
--

[[meta-node-foldr]]
.Meta-Node: `foldr(f, l, :(x))`
--
Folds a list to a single value, starting from the last element.

`f` is first applied on the last element of `l` and `x`. If the `x`
argument is not provided or `x` fails to evaluate to a value, `f` is
first applied on the last two elements of `l`. Subsequently `f` is
applied on the previous element of `l` and the result of the previous
application, until the beginning of list `l` is reached.

If `l` only has a single element and `x` is not provided, the element
is returned as is. If `l` is empty and `x` is provided, `x` is
returned as is.


`f`:: Function of two arguments.
`l`:: List to fold.
`x` (_Optional_):: second argument to the application of `f` on the last element of `l`.
--

[[meta-node-map]]
.Meta-Node: `map(f, list)`
--
Applies a function on each element of a list.

Returns a list containing the result of applying `f` on each element
of `list` in turn.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.
--

[[meta-node-filter]]
.Meta-Node: `filter(f, list)`
--
Filters elements from a list.

Returns a list containing only the elements of `list` for which the
function `f` returns true,

[horizontal]
`f`:: Function of one argument, which should return true if the
argument should be retained in the list or false if it should be
removed.

`list`:: The list to filter.
--

[id="meta-node-every?"]
.Meta-Node: `every?(f, list)`
--
Returns true if `f` returns true for every element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.
--

[id="meta-node-some?"]
.Meta-Node: `some?(f, list)`
--
Returns true if `f` returns true for at least one element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.
--

[id="meta-node-not-any?"]
.Meta-Node: `not-any?(f, list)`
--
Returns true if `f` returns false for every element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.
--

[id="meta-node-not-every?"]
.Meta-Node: `not-every?(f, list)`
--
Returns true if `f` returns false for at least one element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.
--

=== Strings ===

[[meta-node-string-at]]
.Meta-Node: `string-at(string, index)`
--
Returns the character at a given index in the string.

If the index is greater than the number of characters in this string,
returns a failure.

[horizontal]
`string`:: The string.
`index`:: The index of the character.
--

[[meta-node-string-concat]]
.Meta-Node: `string-concat(string, str1, str2)`
--
Concatenates `str2` to the end of `str1`.

[horizontal]
`str1`:: The first string.
`str2`:: The string which is concatenated to `str1`.

--

[id="meta-node-string->list"]
.Meta-Node: `string->list(string)`
--
Returns a list containing the characters in a string.

[horizontal]
`string`:: The string.
--

[id="meta-node-list->string"]
.Meta-Node: `list->string(list)`
--
Returns a string containing the concatenation of the elements in a list.

Each element of `list` is converted to a string and concatenated to
the result string.

[horizontal]
`list`:: List of elements to concatenate.
--

[[meta-node-format]]
.Meta-Node: `format(string, ..(args))`
--
Creates a formatted string, with the placeholders in the string
replaced by the arguments in `args`.

The sequence `%s` designates a placeholder which is to be replaced by
an argument. The first placeholder is replaced by the first argument,
the second with the second argument and so on. Each argument is
converted to a string prior to being substituted into the result
string.

The sequence `%%` designates a literal `%` character and is thus
replaced with a `%`.

[horizontal]
`string`:: The format string.
`args`:: The arguments to substitute into the string.
--

=== Operator Table ===

[cols="<,>,>", options="header"]
|====================
| Operator | Precedence | Associativity

| `.`       | 1000       | left
| `@`       | 800        | left
| `catch`   | 850        | left
| `*`       | 200        | left
| `/`       | 200        | left
| `+`       | 100        | left
| `-`       | 100        | left
| `<`       | 50         | left
| `<=`      | 50         | left
| `>`       | 50         | left
| `>=`      | 50         | left
| `=`       | 50         | left
| `!=`      | 50         | left
| `and`     | 25         | left
| `or`      | 20         | left
| `!-`      | 15         | right
| `->`      | 10         | right
| `<-`      | 10         | left
| `:`       | 5          | right
|====================
