== Core Module ==

(((Core Module, Standard Library)))
(((core, module, Standard Library)))

The `core` module provides the language primitives and the standard
library.

=== Literals ===

(((Literals, Core Module, Macros)))

[[macro-node-quote]]
==== Macro-Node: `'(x)` ====

(((', Core Module, Macro)))

Interprets `x` as a literal symbol rather than a node declaration.

The same symbol object is always returned for a given symbol name.

[horizontal]
`x`:: An atom node expression.


[[macro-node-c]]
==== Macro-Node: `c(x)` ====

(((c, Core Module, Macro)))

Returns `x` interpreted as a literal character.

--
- If `x` is a symbol of one character, the character is returned.
- If `x` is a string, the first character in the string is returned.
- If `x` is an integer in the range 0 -- 9, the character
  corresponding to the digit is returned.
--

[horizontal]
`x`:: The value to convert to a character.


[[macro-node-ref]]
==== Macro-Node: `&(node)` ====

(((&, Core Module, Macro)))

(((&, Core Module, Macro)))

Returns the raw node object corresponding to the node with identifier
`node`.

[horizontal]
`node`:: The node identifier, which can be any valid node
expression. The expression is processed in the module in which the
macro node instance occurs.


[[core-module-bindings]]
=== Bindings ===

(((Bindings, Core Module, Macros)))

[[macro-node-lbind]]
==== Macro-Node: `->(source, target)` ====

(((`->`, Core Module, Macro)))

Establishes a binding between node `source` and node `target`.

[horizontal]
`source`:: The source node.
`target`:: The target node.

NOTE: Registered as an infix operator with precedence *10* and *right*
associativity.


[[macro-node-rbind]]
==== Macro-Node: `<-(target, source)` ====

(((`<-`, Core Module, Macro)))

Establishes a binding between node `source` and node `target`.

Same as <<macro-node-lbind,`->`>> however the argument order is reversed with the first
argument being the target node and the second argument being the
source node.

[horizontal]
`target`:: The target node.
`source`:: The source node.

NOTE: Registered as an infix operator with precedence *10* and *left*
associativity.


[[macro-node-context]]
==== Macro-Node: `@(node, context)` ====

(((@, Core Module, Macro)))

Indicates an explicit context to which bindings, involving `node` as
the 'target', should be established.

When the `@` expression appears as the target of a binding, the binding
to `node` is established in the context with identifier `context`,
_see <<_contexts>>_.

`context` may also be a functor of the form `catch(context-id, type)`,
where `context-id` is the context identifier and `type` is a node, of
which the value is interpreted as a failure type. In this case the
binding will only be activated if the failure type, of the previous
binding in the context, is equal to `type` by <<meta-node-eq,
`=`>>. _See <<conditional_binding_fail_type>>_.

[horizontal]
`node`:: The node.
`context`:: The context identifier, or catch expression, _see above_.

NOTE: Registered as an infix operator with precedence *800* and *left*
associativity. The `catch` symbol is also registered as an infix
operator with precedence *850* and *left* associativity.


=== Meta-Node Definitions ===

(((Definitions, Core Module, Macros)))


[[macro-node-def]]
==== Macro-Node: `:(id(args...), body)` ====

(((:, Core Module, Macro)))

Defines a meta-node with identifier `id`, argument list `args` and
definition `body`. _See <<_meta_nodes>>_.

[horizontal]
`id`:: Meta-node identifier.
`args`:: Comma-separated list of node identifiers, to which the
meta-node arguments are bound.
`body`:: Node expression making up the definition of the meta-node. If
the definition consists of more than a single expression, it should be
enclosed in braces, _see <<_node_lists,Node Lists>>_.

NOTE: Registered as an infix operator with precedence *5* and *right*
associativity.


[[macro-node-outer]]
==== Macro-Node: `..(node)` ====

(((.., Core Module, Macro)))

Explicitly references a node defined in the enclosing scope of the
meta-node. _See <<_outer_node_references>>_.

[horizontal]
`node`:: The node identifier, which can be any valid node expression.


=== Failures ===

(((Failures, Core Module, Utilities)))

[[meta-node-fail]]
==== Meta-Node: `fail(:(type))` ====

(((fail, Core Module, Meta-Node)))

Returns a failure with a given failure type.

`type` (_Optional_):: The failure type. If not provided the failure returned has no
type.


[[meta-node-fail-type]]
==== Meta-Node: `fail-type(x)` ====

(((fail-type, Core Module, Meta-Node)))

Returns the failure type of `x`.

Returns a failure if `x` does not evaluate to a failure or evaluates
to a failure with no type.

[horizontal]
`x`:: The value of which to return the failure type.


[[meta-node-failsp]]
==== Meta-Node: `fails?(x)` ====

(((fails?, Core Module, Meta-Node)))

Returns true if `x` fails to evaluate to a value.

[horizontal]
`x`:: The value to test for failure.


[[meta-node-succeedsp]]
==== Meta-Node: `?(x)` ====

(((?, Core Module, Meta-Node)))

Returns true if `x` evaluates to a value, false if `x` fails to
evaluate to a value.

[horizontal]
`x`:: The value to test for failure.


[[meta-node-fail-typep]]
==== Meta-Node: `fail-type?(x, type)` ====

(((fail-type?, Core Module, Meta-Node)))

Tests for failure with a given type.

Returns true if `x` fails with failure type equal to `type`, by
<<meta-node-eq,`=`>>. Returns false if the failure type of `x` is not
equal to `type` or `x` does not fail.

[horizontal]
`x`:: The value to check.
`type`:: The failure type.


[[meta-node-test-fail-bind]]
==== Meta-Node: `!-(test, value)` ====

(((!-, Core Module, Meta-Node)))

Returns `value` if `test` does not fail. If `test` fails, the failure
is returned.

[horizontal]
`test`:: The value which is checked for failure.
`value`:: The value which should be returned if `test` does not fail.


[[macro-node-test-fail-functor]]
==== Macro-Node: `!(functor)` ====

(((!, Core Module, Macro)))

Tests that each argument of a functor expression does not fail, before
evaluating the expression.

If at least one argument fails, then the entire functor node fails.

[horizontal]
`functor`:: The functor expression.


=== Arithmetic ===

(((Arithmetic, Core Module)))

[[meta-node-plus]]
==== Meta-Node: `+(x, y)` ====

(((+, Core Module, Meta-Node)))

Computes the sum of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *100* and *left*
associativity.


[[meta-node-minus]]
==== Meta-Node: `-(x, :(y))` ====

(((-, Core Module, Meta-Node)))

Computes the difference of `x` and `y`.

If `y` is not provided, returns the negation of `x`, i.e. `x`
multiplied by `-1`.

`x`:: A number.
`y` ('Optional'):: A number.

NOTE: Registered as an infix operator with precedence *100* and *left*
associativity.


[[meta-node-multiply]]
==== Meta-Node: `*(x, y)` ====

(((*, Core Module, Meta-Node)))

Computes the product of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *200* and *left*
associativity.


[[meta-node-divide]]
==== Meta-Node: `/(x, y)` ====

(((/, Core Module, Meta-Node)))

Computes the quotient of `x` and `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *200* and *left*
associativity.


[[meta-node-rem]]
==== Meta-Node: `%(x, y)` ====

(((%, Core Module, Meta-Node)))

Computes the remainder of the division of `x` by `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *200* and *left*
associativity.


=== Comparison ===

(((Comparison, Core Module)))

[[meta-node-lt]]
==== Meta-Node: `<(x, y)` ====

(((<, Core Module, Meta-Node)))

Returns true if `x` is less than `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-lte]]
==== Meta-Node: `<=(x, y)` ====

(((`<=`, Core Module, Meta-Node)))

Returns true if `x` is less than or equal to `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-gt]]
==== Meta-Node: `>(x, y)` ====

(((>, Core Module, Meta-Node)))

Returns true if `x` is greater than `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-gte]]
==== Meta-Node: `>=(x, y)` ====

(((>=, Core Module, Meta-Node)))

Returns true if `x` is greater than or equal to `y`.

[horizontal]
`x`:: A number.
`y`:: A number.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-eq]]
==== Meta-Node: `=(a, b)` ====

(((=, Core Module, Meta-Node)))

Returns true if `a` is equal to `b`.

--
- 'Numbers' are equal if they represent the same numeric
  value.
- 'Characters' are equal if they represent the same
  character.
- 'Strings' are equal if they have the same contents.
- Otherwise `a` and `b` are equal if they evaluate to the same object.
--

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


[[meta-node-neq]]
==== Meta-Node: `!=(a, b)` ====

(((!=, Core Module, Meta-Node)))

Returns true if `a` is not equal to `b`.

_See <<meta-node-eq,`=`>> for the rules of equality_.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *50* and *left*
associativity.


=== Logical Operators ===

(((Logical Operators, Core Module)))

[[meta-node-and]]
==== Meta-Node: `and(x, y)` ====

(((and, Core Module, Meta-Node)))

Logical AND.

Returns the value of `y` if `x` evaluates to true.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *25* and *left*
associativity.


[[meta-node-or]]
==== Meta-Node: `or(x, y)` ====

(((or, Core Module, Meta-Node)))

Logical OR.

Returns the value of `x`, if it evaluates to true, otherwise returns
the value of `y`.

[horizontal]
`x`:: A value.
`y`:: A value.

NOTE: Registered as an infix operator with precedence *20* and *left*
associativity.


[[meta-node-not]]
==== Meta-Node: `not(x)` ====

(((not, Core Module, Meta-Node)))

Logical NOT.

Returns true if `x` evaluates to false.

[horizontal]
`x`:: A value.


[[meta-node-if]]
==== Meta-Node: `if(condition, true-value, :(false-value))` ====

(((if, Core Module, Meta-Node)))

Returns `true-value` if `condition` is true otherwise returns
`false-value`.

If `false-value` is not provided, a failure is returned if `condition`
evaluates to false.

`condition`:: The condition.
`true-value`:: Value to return if `condition` is true.
`false-value` (_Optional_):: Value to return if `condition` is false. If
not provided defaults to a failure.


[[macro-node-case]]
==== Macro-Node: `case(..(clauses))` ====

(((case, Core Module, Macro)))

--------------------------------------------------
<clause> = <condition> : <value>
--------------------------------------------------

Expands to nested <<meta-node-if,`if`>> expressions.

Each argument is a `clause` is of the form `condition : value`. The
`case` expression evaluates to the `value` corresponding to the first
clause of which the `condition` node evaluates to true. The final
clause may also be of the form `value`, in which case it becomes the
default value, to which the `case` expression evaluates if the
conditions of all the other clauses evaluate to false.

[horizontal]
`clauses`:: The clauses.

.Example
--------------------------------------------------
case(
    a < b : a,
    b >= a : b
)

# Is equivalent to:

if(a < b, a, if(b >= a, b))
--------------------------------------------------

.Example with default value
--------------------------------------------------
case(
    a < b : -1,
    b > a : 1,
    0
)

# Is equivalent to:

if(a < b, -1, if(b > a, 1, 0))
--------------------------------------------------


=== Types ===

(((Type Conversions, Core Module)))
(((Type Checks, Core Module)))

[[meta-node-int]]
==== Meta-Node: `int(x)` ====

(((int, Core Module, Meta-Node)))

Converts `x` to an *integer* value.

    - If `x` is an *integer* returns `x`.
    - If `x` is a *real* returns `x` with the fractional part
      truncated.
    - If `x` is a *string*, attempts to parse an integer from
      `x`. Returns the parsed value if successful otherwise
      returns a failure.

If `x` is neither of the above returns a failure.

[horizontal]
`x`:: The value to convert to an integer.


[[meta-node-real]]
==== Meta-Node: `real(x)` ====

(((real, Core Module, Meta-Node)))

Converts `x` to a *real* number value.

    - If `x` is an *integer* or *real* returns `x`.
    - If `x` is a *string*, attempts to parse a real number from
      `x`. Returns the parsed value if successful otherwise
      returns a failure.

If `x` is neither of the above returns a failure.

[horizontal]
`x`:: The value to convert to a real.


[[meta-node-string]]
==== Meta-Node: `string(x)` ====

(((string, Core Module, Meta-Node)))

Converts `x` to a *string*.

[horizontal]
`x`:: The value to convert to a string.


[[meta-node-to-int]]
==== Meta-Node: `to-int(x)` ====

(((to-int, Core Module, Meta-Node)))

Converts `x` to an *integer* value.

Same as <<meta-node-int,`int`>> however with the `target-node`
attribute set to <<meta-node-int,`int`>>. As such, in the following:

--------------------------------------------------
a -> to-int(b)
--------------------------------------------------

Node `b` is set to the value of `a` converted to an integer.

[horizontal]
`x`:: The value to convert.


[[meta-node-to-real]]
==== Meta-Node: `to-real(x)` ====

(((to-real, Core Module, Meta-Node)))

Converts `x` to an *real* number value.

Same as <<meta-node-real,`real`>> however with the `target-node`
attribute set to <<meta-node-real,`real`>>. As such, in the following:

--------------------------------------------------
a -> to-real(b)
--------------------------------------------------

Node `b` is set to the value of `a` converted to a real number.

[horizontal]
`x`:: The value to convert.


[[meta-node-to-string]]
==== Meta-Node: `to-string(x)` ====

(((to-string, Core Module, Meta-Node)))

Converts `x` to an *integer* value.

Same as <<meta-node-string,`string`>> however with the `target-node`
attribute set to <<meta-node-string,`string`>>. As such, in the following:

--------------------------------------------------
a -> to-string(b)
--------------------------------------------------

Node `b` is set to the value of `a` converted to a string.

[horizontal]
`x`:: The value to convert.


[[meta-node-intp]]
==== Meta-Node: `int?(x)` ====

(((int?, Core Module, Meta-Node)))

Returns true if `x` is an *integer*.

[horizontal]
`x`:: The value to test.


[[meta-node-realp]]
==== Meta-Node: `real?(x)` ====

(((real?, Core Module, Meta-Node)))

Returns true if `x` is a *real*.

[horizontal]
`x`:: The value to test.


[[meta-node-stringp]]
==== Meta-Node: `string?(x)` ====

(((string?, Core Module, Meta-Node)))

Returns true if `x` is a *string*.

[horizontal]
`x`:: The value to test.


[[meta-node-infp]]
==== Meta-Node: `inf?(x)` ====

(((inf?, Core Module, Meta-Node)))

Returns true if `x` is either positive or negative infinity.

[horizontal]
`x`:: The value to test.


[[meta-node-nanp]]
==== Meta-Node: `NaN?(x)` ====

(((NaN?, Core Module, Meta-Node)))

Returns true if `x` is a *NaN* value.

[horizontal]
`x`:: The value to test.


=== Lists ===

(((Lists, Core Module)))

Lists are represented by a special `cons` type, in which the 'head'
stores the first element of the list and the 'tail' stores the list of
remaining elements. Neither the 'head' nor the 'tail' are evaluated
until they are actually referenced and used.

The end of list is represented by a failure with the type being a node
reference to the meta-node <<meta-node-Empty, `Empty`>> (`&(Empty)`).


[[meta-node-cons]]
==== Meta-Node: `cons(head, tail)` ====

(((cons, Core Module, Meta-Node)))

Creates a list with the `head` as the first element and `tail` as
the list of remaining elements.

[horizontal]
`head`:: The first element of the list.
`tail`:: The list containing the remaining elements after the first.


[[meta-node-head]]
==== Meta-Node: head(list) ====

(((head, Core Module, Meta-Node)))

Returns the 'head' (first element) of a list.

If `list` is not a list returns a failure value.

[horizontal]
`list`:: The list.


[[meta-node-tail]]
==== Meta-Node: `tail(list)` ====

(((tail, Core Module, Meta-Node)))

Returns the 'tail', the list containing the elements after the first
element, of a list.

If `list` is not a list returns a failure value.

[horizontal]
`list`:: The list.


[[meta-node-consp]]
==== Meta-Node: `cons?(thing)` ====

(((cons?, Core Module, Meta-Node)))

Returns true if `thing` is a list of at least one element, false
otherwise.

NOTE: Does not return true if `thing` is an empty list.

[horizontal]
`list`:: The list.


[[meta-node-Empty]]
==== Meta-Node: Empty() ====

(((Empty, Core Module, Meta-Node)))

Returns a failure with type indicating an empty list.

NOTE: The failure type is `&(Empty)`, _see <<node_references>>_.


[[meta-node-list]]
==== Meta-Node: `list(..(xs))` ====

(((list, Core Module, Meta-Node)))

Creates a list with elements `xs`.

[horizontal]
`xs`:: The list elements.


[[meta-node-list-star]]
==== Meta-Node: `list*(..(xs))` ====

(((list*, Core Module, Meta-Node)))

Creates a list containing, as elements, all the arguments in `xs`
excluding the last. The last argument in `xs` is treated as a list
containing the remaining elements.

[horizontal]
`xs`:: The list elements, with the last argument being the list
containing the remaining elements.


[[meta-node-list-bang]]
==== Meta-Node: `list!(..(xs))` ====

(((list!, Core Module, Meta-Node)))

Creates a list containing, as elements, all the arguments in `xs`.

Unlike `list`, if at least one of `xs` fails to evaluate to a value, a
failure is returned.

[horizontal]
`xs`:: The list elements.


[[meta-node-nth]]
==== Meta-Node: `nth(list, n)` ====

(((nth, Core Module, Meta-Node)))

Retrieves the element of a list at a particular index.

Returns a failure of type <<meta-node-Empty, `Empty`>> if `n` is
greater than the number of elements in `list`.

[horizontal]
`list`:: The list.
`n`:: The index of the element to retrieved.


[[meta-node-append]]
==== Meta-Node: `append(list1, list2)` ====

(((append, Core Module, Meta-Node)))

Returns a list containing the elements of `list2` appended to
`list1`.

[horizontal]
`list1`:: The initial list.
`list2`:: The list which is appended onto `list1`.


[[meta-node-foldl1]]
==== Meta-Node: `foldl'(x, f, list)` ====

(((foldl', Core Module, Meta-Node)))

Folds a list to a single value, starting from the first element.

The function `f` is first applied on `x` and the <<meta-node-head, 'head'>> of
`list`. Subsequently, `f` is applied on the result of the previous
application and the next element of `list`, until the end of `list` is
reached.

[horizontal]
`x`:: Initial first argument to `f`.
`f`:: Function of two arguments.
`list`:: List to fold.


[[meta-node-foldl]]
==== Meta-Node: `foldl(f, list)` ====

(((fold, Core Module, Meta-Node)))

Folds a list to a single value, starting from the first element.

Same as <<meta-node-foldl1,`foldl'`>> except the <<meta-node-head, 'head'>> of `list` is
used as the initial first argument to the fold function `f`.

[horizontal]
`f`:: Function of two arguments.
`list`:: List to fold.


[[meta-node-foldr]]
==== Meta-Node: `foldr(f, list, :(x))` ====

(((foldr, Core Module, Meta-Node)))

Folds a list to a single value, starting from the last element.

`f` is first applied on the last element of `list` and the value of
`x`. If the `x` argument is not provided or `x` fails to evaluate to a
value, `f` is first applied on the last two elements of
`list`. Subsequently `f` is applied on the previous element of `list`
and the result of the previous application, until the 'head' of list
`list` is reached.

If `list` only has a single element and `x` is not provided, the
element is returned as is. If `l` is empty and `x` is provided, `x` is
returned as is.


`f`:: Function of two arguments.
`list`:: List to fold.
`x` (_Optional_):: Second argument to the application of `f` on the
last element of `list`.


[[meta-node-map]]
==== Meta-Node: `map(f, list)` ====

(((map, Core Module, Meta-Node)))

Applies a function on each element of a list.

Returns a list containing the result of applying `f` on each element
of `list` in turn.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


[[meta-node-filter]]
==== Meta-Node: `filter(f, list)` ====

(((filter, Core Module, Meta-Node)))

Filters elements from a list.

Returns a list containing only the elements of `list` for which the
function `f` returns true.

[horizontal]
`f`:: Function of one argument, which should return true if the
argument should be retained in the list or false if it should be
removed.

`list`:: The list to filter.


[[meta-node-everyp]]
==== Meta-Node: `every?(f, list)` ====

(((every?, Core Module, Meta-Node)))

Returns true if `f` returns true for every element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


[[meta-node-somep]]
==== Meta-Node: `some?(f, list)` ====

(((some?, Core Module, Meta-Node)))

Returns true if `f` returns true for at least one element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


[[meta-node-not-anyp]]
==== Meta-Node: `not-any?(f, list)` ====

(((not-any?, Core Module, Meta-Node)))

Returns true if `f` returns false for every element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


[[meta-node-not-everyp]]
==== Meta-Node: `not-every?(f, list)` ====

(((not-every?, Core Module, Meta-Node)))

Returns true if `f` returns false for at least one element of `list`.

[horizontal]
`f`:: Function of one argument.
`list`:: The list.


=== Strings ===

(((Strings, Core Module)))

[[meta-node-string-at]]
==== Meta-Node: `string-at(string, index)` ====

(((string-at, Core Module, Meta-Node)))

Returns the character at a given index in the string.

If the index is greater than the number of characters in this string,
returns a failure.

[horizontal]
`string`:: The string.
`index`:: The index of the character.


[[meta-node-string-concat]]
==== Meta-Node: `string-concat(string, str1, str2)` ====

(((string-concat, Core Module, Meta-Node)))

Concatenates `str2` to the end of `str1`.

[horizontal]
`str1`:: The first string.
`str2`:: The string which is concatenated to `str1`.



[[meta-node-string-to-list]]
==== Meta-Node: `string->list(string)` ====

(((`string->list`, Core Module, Meta-Node)))

Returns a list containing the characters in a string.

[horizontal]
`string`:: The string.


[[meta-node-list-to-string]]
==== Meta-Node: `list->string(list)` ====

(((`list->string`, Core Module, Meta-Node)))

Returns a string containing the concatenation of the elements in a list.

Each element of `list` is converted to a string and concatenated to
the result string.

[horizontal]
`list`:: List of elements to concatenate.


[[meta-node-format]]
==== Meta-Node: `format(string, ..(args))` ====

(((format, Core Module, Meta-Node)))

Creates a formatted string, in which placeholders are replaced by the
arguments in `args`.

The sequence `%s` designates a placeholder which is to be replaced by
an argument. The first placeholder is replaced by the first argument,
the second with the second argument and so on. Each argument is
converted to a string prior to being substituted into the result
string.

The sequence `%%` designates a literal `%` character and is thus
replaced with a `%`.

[horizontal]
`string`:: The format string.
`args`:: The arguments to substitute into the string.


=== Introspection ===

(((Introspection Utilities, Core Module)))

The meta-nodes in this section provide functionality for introspecting
the nodes comprising a program. These meta-nodes may only be used from
within macro nodes during compilation, and not during runtime.

[[meta-node-nodep]]
==== Meta-Node: `node?(thing)` ====

(((node?, Core Module, Meta-Node)))

Returns true if `thing` is a node object.

[horizontal]
`thing`:: The thing to check whether it is a node.


==== Meta-Node: `find-node(node, :(module))` ====

(((find-node, Core Module, Meta-Node)))

Looks-up a node in a module.

Returns the node object or a failure if no node is found.

`node`:: The node to lookup, which can be any node expression.
`module` ('Optional'):: The module in which to look-up the
node. Defaults to the current module, set by the last `:module`
declaration that is processed.

NOTE: Currently there is no way to retrieve a module object, thus the
`module` argument is not used. This functionality will be added in a
future release.


==== Meta-Node: `get-attribute(node, attribute)` ====

(((get-attribute, Core Module, Meta-Node)))

Retrieves the value of an attribute of a node.

Returns a failure if the attribute is not set.

[horizontal]
`node`:: The node object.
`attribute`:: The attribute identifier.


=== Pattern Matching ===

(((Pattern Matching, Core Module)))
(((Functor Patterns, Core Module, Pattern Matching)))

Pattern matching is provided by the core module in the form of
bindings involving the meta-node instance, which is to be matched, as
the target. The binding succeeds if the pattern matches, otherwise it
fails.

A meta-node which supports pattern matching, has a `target-node` or
`target-transform`, _see <<_instances_as_targets>>_, such that when an
instance of the meta-node appears as the target of a binding, the
argument nodes are bound to the values, required in order for the
meta-node to return a value that is equivalent to the value of the
source node. When there are such values, the pattern is said to have
'matched'. If there is no possible value for at least one argument
node, all argument nodes should evaluate to failures. In this case the
pattern has not 'matched'

.Example
--------------------------------------------------
x -> int(y)
--------------------------------------------------

In the example, above, `y` is bound to the value of `x` if it is an
integer, otherwise `y` evaluates to a failure. There is no argument
which will result in `int` returning a non-integer value thus if the
source node, `x`, is not an integer the argument node, `y`, is bound
to a failure. Since `int` returns the value of its argument directly,
when it is an integer, the argument node is simply bound to the source
node.

.Example
--------------------------------------------------
x -> list(y, z)
--------------------------------------------------

In the example, above, `y` is bound to the first element of `x` and
`z` is bound to the second element of `x` if `x` is a list of two
elements. These bindings will result in a list, equivalent to `x`,
being produced when they are passed to the `list` meta-node.

==== Nested Patterns ====

(((Nested Patterns, Core Module, Pattern Matching)))

Patterns may be nested, that is an argument to a meta-node instance is
itself a meta-node instance of which the operator meta-node supports
pattern matching. When the arguments contain one or more nested
patterns, the bindings to the argument nodes should only succeed if
all nested patterns 'match'.

.Example
--------------------------------------------------
x -> list(int(y), z)
--------------------------------------------------

The example, above, is similar to the previous example except with the
additional condition that the first element of `x` should also be an
integer. That is `y` is bound to the first element of `x` and `z` to
the second element of `x` if `x` is a list of two elements of which
the first element is an integer.


==== Constant Patterns ====

(((Constant Patterns, Core Module, Pattern Matching)))

Constant patterns comprise a constant value as opposed to a
node. These patterns 'match' when the source node is equal, by
<<meta-node-eq, `=`>>, to the constant value. Constant patterns do not
result in any bindings being established however they do affect the
condition of the pattern in which they are nested.

IMPORTANT: Constant patterns may only be used as arguments to a
meta-node instance, of which at least one of the arguments is not a
constant pattern.

Constant values include any literal constants, such as numbers,
strings as well as character literals, produced by the <<macro-node-c,
`c`>> macro, and literal symbols, produced by the
<<macro-node-quote,`'`>> macro.

.Example
--------------------------------------------------
x -> list(1, y, z)
--------------------------------------------------

In the example, above, `y` is bound to the second element of `x` and
`z` to the third element of `x` if `x` is a list of three elements of
which the first element is equal to `1`.

The following are examples of invalid uses of constant patterns:

.Examples: Invalid use of Constant Patterns
--------------------------------------------------
# Invalid as the pattern is not nested
x -> 1

# Invalid as at least one argument should not be a constant.
x -> list(1, 2)
--------------------------------------------------

CAUTION: Functor nodes, of which the arguments are all constants, such
as `1 + 1`, are only treated as constant patterns if the meta-node
supports pattern matching. In this case the `+` meta-node does not
support pattern matching, thus `1 + 1` is currently not treated as a
constant pattern.


[[matchers, Matchers]]
==== Matchers ====

(((matcher, Attribute, Pattern Matching)))
(((Pattern Object, Core Module, Pattern Matching)))

The `matcher` node attribute stores a meta-node which is called to
construct the pattern for a given list of arguments. The 'matcher'
meta-node is called with two arguments: the place to be matched, which
should become the 'source' node of any bindings established by the
pattern, and the pattern 'functor' expression itself (including the
operator). The meta-node should return a `Pattern` object, which is a
dictionary containing the following entries:

`condition`:: The node expression which evaluates to true if the
pattern matches. This should include the conditions of the argument
nodes if they are patterns themselves.

`bindings`:: List of bindings established by the pattern. If there are
no bindings established by the pattern, then this entry should be set
to the empty list, _see <<meta-node-Empty, `Empty`>>.
+
--
IMPORTANT: The bindings should not be conditioned on `condition` as
they will be conditioned later when the node declarations for the
entire pattern (including the parent patterns) is constructed. _See
<<conditional_bindings>>_.
--

TIP: Pattern objects may be created with the <<meta-node-Pattern,
`Pattern`>> meta-node.

All bindings, established by a pattern, should be established in an
explicit context with identifier `match`. This allows multiple
patterns to be specified on a single node, with the node being set to
the value corresponding to binding of the first pattern that
'matches'.

.Example: Multiple Patterns
--------------------------------------------------
x -> int(y)
x -> list(int(y))
x -> list("x", int(y))
--------------------------------------------------

The example above contains multiple patterns involving a single node
`y`.

`y` is bound to:

. the value of `x` if it is an integer, or
. the first element of `x` if it is a list of one element, which is an
integer, or
. the second element of `x` if it is a list of two elements, with the
first element being the string value `"x"` and the second element
being an integer.

==== Utilities ====

(((Pattern Matching Utilities, Core Module, Pattern Matching)))

The following meta-nodes are utilities for creating and processing
patterns.

CAUTION: Currently these utilities are not exported from the `core`
module, thus they have to be imported manually if they are to be used
in another module.


[[meta-node-Pattern]]
==== Meta-Node: `Pattern(condition, :(binding))` ====

(((Pattern, Core Module, Meta-Node)))

Creates a `Pattern` object. _See <<matchers>>_

`condition`:: The node expression which evaluates to true if the
pattern matches.

`binding (Optional)`:: List of binding expressions of the bindings
established by the pattern. Defaults to the empty list if not
provided.


[[meta-node-get-matcher]]
==== Meta-Node: `get-matcher(node)` ====

(((get-matcher, Core Module, Meta-Node)))

Returns the 'matcher' function, stored in the `matcher` attribute of a
node.

Returns a failure if the node's `matcher` attribute is not set.

[horizontal]
`node`:: The node object of which to retrieve the 'matcher'.


[[meta-node-make-pattern]]
==== Meta-Node: `make-pattern(place, pattern)` ====

(((make-pattern, Core Module, Meta-Node)))

Creates the `Pattern` object for a pattern expression.

NOTE: Can be used for any pattern, including constant patterns.

`place`:: The place which should be matched to the pattern, i.e. the
source node of the bindings established by the pattern.

`pattern`:: The pattern expression.

NOTE: If `pattern` is a functor expression of which the operator is
not a `meta-node` with a `matcher`, a `Pattern` with a single binding
`place -> pattern`, and no `condition` is returned.


[[meta-node-combine-conditions]]
==== Meta-Node: `combine-conditions(c1, c2)` ====

(((combine-conditions, Core Module, Meta-Node)))

Returns an expression which is the conjunction of two expression, by
<<meta-node-and, `and`>>.

`c1`:: The first condition, on the left hand side of the `and`.
`c2`:: The second condition, on the right hand side of the `and`.

If `c1` evaluates to a failure, returns `c2`. If `c2` evaluates to a
failure, returns `c1`.

TIP: This is useful for creating a condition which combines the
conditions of multiple argument nodes.


[[meta-node-conditionalize-bindings]]
==== Meta-Node: conditionalize-bindings(condition, bindings) ====

(((conditionalize-bindings, Core Module, Meta-Node)))

Returns a list where each binding in `bindings` is conditioned on
`condition`. _See <<conditional_bindings>>_.

`condition`:: The condition on which to condition the bindings.
`bindings`:: List of bindings to condition.


[[meta-node-make-pattern-declarations]]
==== Meta-Node: make-pattern-declarations(pattern) ====

(((make-pattern-declarations, Core Module, Meta-Node)))

Creates the node declarations implementing a pattern.

Returns a single node declaration.

`pattern`:: The `Pattern` object for which to create the declarations.

TIP: The declaration returned by this meta-node is a suitable return
value for a `target-transform` function. _See <<_instances_as_targets>>_.


=== Operator Table ===

(((Operator Table, Core Module)))

[cols="<,>,>", options="header"]
|====================
| Operator | Precedence | Associativity

| `.`       | 1000       | left
| `catch`   | 850        | left
| `@`       | 800        | left
| `*`       | 200        | left
| `/`       | 200        | left
| `+`       | 100        | left
| `-`       | 100        | left
| `<`       | 50         | left
| `<=`      | 50         | left
| `>`       | 50         | left
| `>=`      | 50         | left
| `=`       | 50         | left
| `!=`      | 50         | left
| `and`     | 25         | left
| `or`      | 20         | left
| `!-`      | 15         | right
| `->`      | 10         | right
| `<-`      | 10         | left
| `:`       | 5          | right
|====================
