== Nodes ==

Semantically a Tridash program is composed of a set of stateful
components called nodes, each holding a particular value at a given
moment in time.

Each node has a set of 'dependency' nodes. A change in the value of at
least one of the dependency nodes causes the node to recompute its own
value. The node is said to be an 'observer' of its dependency nodes,
as it actively observes and responds to changes in their
values. Similarly, each node has a set of 'observer' nodes which it
notifies whenever its own value changes.

This 'dependency' -- 'observer' relation is referred to as a binding.

=== Glossary ===

[glossary]
dependency:: A node `a` is said to be a _dependency_ of node `b` if a
change in the value of `a` triggers a change in the value of `b`.

observer:: A node `a` is said to be an _observer_ of node `b` if a
change in the value of `b` triggers a change in the value of `a`.

binding:: A _binding_ is a relation between two nodes `a` and `b`, in
which one node `a` is a _dependency_ of the other `b`, and likewise
the other node `b` is its _observer_.

ancestor:: A node `a` is said to be an _ancestor_ of a node `b` if `a`
is a _dependency_ of `b` or it is an _ancestor_ of a _dependency_ of `b`.

successor:: A node `a` is said to be a _successor_ of a node `b` if
`a` is an _observer_ of `b` or it is a successor of an _observer_ of
`b`.


=== Declaring Nodes ===

In the global scope, nodes are created on the first reference, that is
when their identifier first appears in source code. This can either be
a declaration consisting of the identifier itself or a functor node
declaration of which the node is an argument.

CAUTION: The `self` identifier is reserved as an alias for the
current 'meta-node', _see <<_meta_nodes>>_.

.Examples
--------------------------------------------------
# Results in the creation of node `name`
name

# Results in the creation of nodes `a` and `b`
a -> b

# Results in the creation of nodes `x`, `y` and `f(x, y)`
f(x, y)
--------------------------------------------------

This allows for a relaxed ordering of declarations. A node's
definition need not be complete in order for it to be referenced as an
argument.

Notice that in the last example, above, a node `f(x, y)` was
created. This node corresponds to the functor node expression, thus
functors, with the exception of a few special declarations, are nodes
themselves. From now on a functor node expression refers only to
functors in which the operator refers to a function. Functor
expressions in which the operator does not refer to a function are
referred to as special declarations.

NOTE: Operators which correspond to functions, such as `f` in the
example above are referred to as meta-nodes and the functor expression
as an instance of the meta-node. See <<_meta_nodes>>.

NOTE: Nodes are also created for functors written in infix form,
e.g. for the functor `a + b`, the node `+(a, b)` is created.

A node corresponding to `a -> b` was not created. This is a bind
declaration which is treated rather specially. The `->` is not a
meta-node, that is it does not compute a value, but is a special
operator.

=== Declaring Bindings ===

A binding between two nodes is declared with the special bind operator
`->`.

--------------------------------------------------
a -> b
--------------------------------------------------

The above declares `b` an observer of `a` and likewise `a` a
dependency of `b`. The result is that a change in the value of `a`
will trigger a change in the value of `b`. This is an example of a
simple binding, since the value of `b` is simply set to the value of
`a`.

NOTE: In an explicit binding declaration the dependency, i.e. the
left-hand side of the `->` operator, is referred to as the 'source' node
and the observer, i.e. the right-hand side, is referred to as the
'target' node.

NOTE: The bind operator is registered as an infix operator with
precedence *10* and *right* associativity.

TIP: The `->` operator is in the form of an arrow which indicates the
direction of data-flow, from the node on the left to the node on the
right.

Functional bindings involve a function of 1 or more argument
nodes. Functional bindings are created implicitly in functor node
expressions, with each argument node added as a dependency of the
functor node. A change in the value of at least one argument node
results in the value of the functor node being updated to the result
of reevaluating the expression with the new values of the argument
nodes.

.Example
--------------------------------------------------
a + b
--------------------------------------------------

In the example, above, a functor node `+(a, b)` is created with the
arguments `a` and `b` implicitly added as dependencies of `+(a, b)`. A
change in either `a` or `b` will result in the value of `+(a, b)`
being recomputed.


=== Propagation of Changes ===

As emphasized in the previous sections, changes in the value of a node
are propagated to its observer nodes. The new value is propagated to
each of the observers simultaneously. Each observer then proceeds to
recompute its own value in parallel with the other observers.

.Example
--------------------------------------------------
a -> b
a + n -> c
a + 1 -> d
--------------------------------------------------

Node `a` has three observers: `b`, `+(a, n)`, `+(a, 1)`. Each of `b`,
`+(a, n)` and `+(a, 1)` receives the new value of `a` and immediately
begins computing its new value. There is no strict sequential ordering
of the updating of the values of the observer nodes. The following
orderings are all possible:

    - `b`, `+(a, n)`, `+(a, 1)`
    - `+(a, n)`, `b`, `+(a, 1)`
    - `+(a, 1)`, `+(a, n)`, `b`

Other orderings, including interleaved orderings, are also possible or
it may be that the values of all the observers are updated in
parallel.

It is important to note the semantics when nodes share a common
observer and the change in value of each node is triggered by a common
ancestor node. A node is said to be 'dirtied' if either its value has
changed, or at least one of its dependency nodes has been
'dirtied'. If a node is 'dirtied', all its observers are 'dirtied',
and likewise their observers are 'dirtied' and so on. A node with
multiple dependencies will only recompute its value when it receives a
value change notification from each of its 'dirtied' dependency
nodes. Thus there is no intermediate value where the node's value is
recomputed before all the dependency nodes have recomputed their
values.

CAUTION: This is only the case when the changes in each of the
dependency nodes are triggered by a change in a common ancestor
node. These semantics do no apply when the changes in the dependency
nodes are not triggered by a change in a common ancestor node but by
multiple simultaneous changes in an ancestor of each dependency,
unless the changes in each ancestor are the setting of the initial
values, in which case it is treated as though they have been triggered
by a single common ancestor. See <<literal_bindings>>.

.Example
--------------------------------------------------
a -> b
a + 1 -> c

b + c -> out
--------------------------------------------------

In the example, above, `a` is a common ancestor of dependency nodes
`b` and `c` of node `+(b, c)`. A change in `a` will 'dirty' the
following nodes:

 - `a`
 - `b`
 - `+(a, 1)`
 - `c`
 - `+(b, c)`
 - `out`.

The value of `+(b, c)` will only be recomputed when the values of both
`b` and `c` have been recomputed.

If `b` and `c` did not have the common ancestor `a`, the value of
`+(b, c)` would be computed on each change in the value of either `b`
or `c`, regardless of whether the changes in values of `b` and `c` are
triggered simultaneously or not.

=== Evaluation Strategy ===

The value of a node is not strictly evaluated. This means that a
node's value is only evaluated if it is actually used. In most cases
the result of this is that node's are evaluated lazily, that is they
are evaluated on their first use. However if it can be statically
determined that a node's value will always be used it may be evaluated
before its first use.

.Example: Lazy Evaluation in If Conditions
--------------------------------------------------
a - b -> d1
b - a -> d2

if(a > b, d1, d2)
--------------------------------------------------

In the example, above, `d1` is only evaluated if `a > b` evaluates to
true. Likewise, `d2` is only evaluated if `a > b` evaluates to
false. `a > b` is always evaluated as its value is always used. In
this example, this only results in a performance optimization since
the values of node's which are not used are not needlessly
computed. However, if `d1` or `d2` were bound to a recursive meta-node
call, _see <<_meta_nodes>>_, an infinite loop of recursive calls would
result had `d1` and `d2` not been evaluated lazily.

A node's value is evaluated at most once. Referencing the node's value
in more than one location will not cause it to be evaluated more than
once. This applies to functor nodes as well as atom nodes.

.Example: Multiple Usage of Nodes
--------------------------------------------------
# Node `f(x, y)` is used in 2 places however it will only be evaluated
# once.

f(x, y) + a -> node1
f(x, y) + b -> node2
--------------------------------------------------

=== Contexts ===

The function which computes a node's value is controlled by the node's
context at that moment in time. The node context stores information
about the function and which of the dependency nodes are operands to
the function. Contexts are created whenever a binding between two nodes is
established.

The most simple context function is the passthrough, created when a
simple binding between two nodes is established. With this function,
the node's value is simply set to the value of its dependency node.

.Passthrough Example
--------------------------------------------------
# `b` is set to the value of `a` whenever it changes

a -> b.
--------------------------------------------------

Contexts with more complex functions, of more than one operand, are
created for each functor node expression. The created context has the
operator as the context function and the arguments as the context
operands.

.Functor Node Example
--------------------------------------------------
# A functor node `+(a, b)` is created with a `+` context.
# `a` and `b` are added to the operands of the `+` context.

a + b
--------------------------------------------------

A node can have more than one context. A context is 'activated',
meaning its function is evaluated to compute the node's value,
whenever the value of one of its operand nodes changes.

.Multiple Context Example
--------------------------------------------------
a -> x
b -> x
c -> x
--------------------------------------------------

When the value of `a` changes, the `a` context of `x` is activated and
the value of `x` is set to the value of `a`. Similarly when `b` or
`c`'s value changes, the `b` or `c` context is activated,
respectively, and `x`'s value is set to the value of `b` or `c`,
respectively.

[WARNING]
==================================================
It is an error for two or more contexts of a single node to be
activated at the same time. This occurs when either both contexts have
a common operand or an operand from one context shares a common
ancestor with an operand from the other context.

.Example 1
--------------------------------------------------
# Node `a` is a dependency of `b`
# Node `a` is a dependency of `+(a, c)`
# Both `b` and `+(a, c)` are dependencies of `x`

a -> b
b -> x

a + c -> x
--------------------------------------------------

In the example, above, node `a` is a dependency node of `b` which is
an operand of the `b` context of `x`. However, node `a` is also a
dependency of node `+(a, c)` (`a + c`), which is an operand of the
`+(a, c)` context of `x`. A change in the value of `a` would trigger a
change in the value of both `b` and `+(a, c)` thus the value to which
`b` should be set is ambiguous.

Structure checking is performed at compile-time, thus the above
example, and all such scenarios, will result in a compilation error
along the lines: `Semantic Error: Node x has multiple contexts
activated by a single common ancestor`.
==================================================

==== Two-Way Bindings ====

A dependency of a node may also be an observer of the same node. This
allows for a two-way binding in which data may flow from either
direction. In this case only the observer nodes which are not also
operands of the node's current context are notified of a change in the
node's value.

.Example
--------------------------------------------------
# A two-way binding is established between `a` and `b`
a -> b
b -> a

a -> c

d -> a
--------------------------------------------------

In the above example, both `b` and `c`, which are observers of
`a`, will be notified of a change in the value of `a` triggered by a
change in the value of `d`. This will trigger a change in the value of
`b` however `a` will not be notified of this change as the change was
triggered by `a`, itself.

In the case of a change in the value of `a` triggered by a change in
the value of `b`, only the observer `c` of `a` will be notified of the
change.

[WARNING]
==================================================
Cycles, other than two-way bindings between a pair of nodes, will
result in a compilation error.

.Example
--------------------------------------------------
a + 1 -> b
b -> a
--------------------------------------------------
==================================================


[[literal_bindings,Literal Bindings]]
==== Literal Bindings ====

A binding in which the dependency is a literal value, is interpreted
as setting the initial value of a node. A special `init` context is
created, which has no operands and has the literal value as its
function.

Initial values are set on the launch of the application, and are
treated as an ordinary value change to the initial value. The initial
active context of the node is the `init` context. If a node is not
given an initial value, its initial value is a failure value, _see
<<_failures>>_.

.Examples
--------------------------------------------------
0 -> counter
"hello" -> message
10.5 -> threshold
--------------------------------------------------

IMPORTANT: The setting of the initial values of each node, is treated
as having been triggered by a single common ancestor node. _See
<<_propagation_of_changes>> for the implications of this_.

[[explicit_contexts, Explicit Contexts]]
==== Explicit Contexts ====

The context to which a binding is established can be set explicitly
with the special `:context` operator.

.Syntax
--------------------------------------------------
:context(node, context-id)
--------------------------------------------------

The effect of this expression, when it appears as the target of a
binding, is that the binding to `node` will be established in the
context with identifier `context-id`. The identifier can be a symbol
or a functor.

.Example
--------------------------------------------------
# Context `my-context` of b has a passthrough value function to the
# value of the dependency `a`.

a -> :context(b, my-context)
--------------------------------------------------

When a `:context` declaration appears in source position it is
equivalent to an ordinary reference to the `node`.

Multiple bindings to the same explicit context can be established. The
function of the context then selects the value of the first
dependency, ordered by the declaration order in the source file, which
does not 'fail' to evaluate to a value, _see <<_failures>>._


.Example
--------------------------------------------------
a -> :context(node, ctx)
b -> :context(node, ctx)
c -> :context(node, ctx)
--------------------------------------------------

`node` evaluates to:

    - The value of `a` if `a` evaluates to a value.
    - The value of `b` if `a` fails to evaluate to a value.
    - The value of `c` if both `a` and `b` fail to evaluate to a value.

If `a`, `b` and `c` all fail to evaluate to a value, `node` evaluates
to the failure value of `c`.

TIP: The `@` macro from the `core` module, which is a shorthand for the
`:context` operator, is the preferred way of establishing bindings to
explicit contexts in source code. _See <<core-module-bindings>>_.

=== Failures ===

Failures are a special type of value which represents the absence of a
value or the failure to compute a value. Failures can either be
created by 'conditional bindings', in which the condition node
evaluates to 'false', or by the `fail` meta-node, from the `builtin`
module.

Functions which expect an argument node to evaluate to a value will
fail if at least one of the arguments fails. In formal terms, if the
result of a function requires that the value of an argument, which
fails to evaluate to a value, be evaluated, the entire function fails
to evaluate to a value. The following are examples of functions which
fail if at least one of the arguments fails: `+`, `-`, `*`, `/`.

If the result of a function is a dictionary, and a dictionary entry
fails to evaluate to a value, it is only that dictionary entry that
fails, the function still returns a dictionary.

==== Conditional Bindings ====

A binding declaration `a -> b` can, itself, be treated as a node, to
which an explicit binding can be established with the binding node as
the target.

--------------------------------------------------
c -> (a -> b)
--------------------------------------------------

The result of this declaration is that the binding `a -> b` is only
active if the condition node `c` evaluates to a 'true' value, any
non-zero value. If `c` evaluates to 'false' (`0`), `b` is not set to
the value of `a` but is set to a failure value.

A binding declaration, with a binding node as the target, changes the
function of the context of the binding to return a failure value if
the value of the condition node is 'false'. The binding node `a -> b`
(`->(a, b)` in prefix notation), is added as a dependency of `b` and
as an operand of the context corresponding to the binding `a ->
b`. The binding node is itself an observer of `c` with a simple
passthrough function. This allows you to reference the 'status' of the
binding by referencing the binding node, `a -> b`.

.Example: Simple Validation
--------------------------------------------------
# Validate that `i` has a value > 0
# Propagate value of `i` to `j`

i > 0 -> (i -> j)

# Perform some computation with `j` which is guaranteed to either be a
# numeric value greater than zero or a failure.
...
--------------------------------------------------

TIP: The bind `->` operator has 'right' associativity, thus the
parenthesis in `c -> (a -> b)` can be omitted: `c -> a -> b`.


Conditional bindings to an explicit context can also be established,
_see <<explicit_contexts>>_. If a condition node evaluates to
'false', it is treated as though the corresponding dependency node has
failed to evaluate to a value. The context's function then evaluates
to the next dependency which does not fail to evaluate to a value. If
all condition nodes evaluate to 'false', the node fails to evaluate to
a value.


.Example: Conditional Bindings and Explicit Contexts
--------------------------------------------------
cond1 -> (a -> :context(node, ctx))
cond2 -> (b -> :context(node, ctx))
c -> :context(node, ctx)
--------------------------------------------------

    - If `cond1` evaluates to false, it is treated as though `a` has
      failed to evaluate to a value.
    - If `cond2` evaluates to false, it is treated as though `b` has
      failed to evaluate to a value.

The net result is that `node` evaluates to:

    - `a` if `cond1` evaluates to true.
    - `b` if `cond2` evaluates to true.
    - `c` if neither `cond1` not `cond2` evaluate to true, or both `a`
      and `b` fail to evaluate to a value.


==== Explicit Failures and Failure Types ====

Failure values can also be created explicitly with the `fail`
meta-node, from the `builtin` module. This meta-node takes one
optional argument: a value indicating the failure type. If the failure
type is not provided, the failure returned does not have a type.

.Example: Explicit Failure with Type
--------------------------------------------------
# Bind `b` to `a` if `c` is true
c -> (a -> :context(b, ctx))

# If `c` is false set `b` to an explicit failure
fail("my-type") -> :context(b, ctx)
--------------------------------------------------

The failure type of a 'failure value' can be retrieved with the
`fail-type` meta-node. This meta-node takes a single argument, which
if it fails to evaluate to a value, returns the failure type
associated with the failure. If the argument does not fail to evaluate
to a value, or the failure has no type associated with it, `fail-type`
returns a failure.

.Example: Querying Failure Type
--------------------------------------------------
# Compare failure type of `b`, to "my-type" from example above

fail-type(c) = "my-type" -> c-fails?
--------------------------------------------------

The failure type is useful to identify the cause of a failure, since
failures are used to represent many classes of errors, such as type
errors, out of range errors, no value errors, as well as representing
special classes of values such as the empty list.

NOTE: Currently failure types are only used, in the core language and
module, to represent the empty list. In the remaining circumstances,
in which failures are generated, there is no failure type. This will
be rectified in the next release.

==== Conditionally Active Bindings based on Failure Type ====

The special `:context` operator takes an optional third argument which
is a test function that is evaluated prior to activating the binding
after the previous binding fails. The test function is applied on a
single argument, the failure type of the previous binding. If the
function returns 'true' the binding is activated otherwise this
binding fails with the same failure type as the preceding binding.

TIP: The `@` macro, from the `core` module, contains a shorthand
syntax for establishing a binding to an explicit context with a test
function that compares the failure type to a given value. _See
<<core-module-bindings>>_.

=== Input Nodes ===

Input nodes are the nodes which receive the application input, which
could be the value entered in a text field of the user interface (UI),
data received from the network, etc. Input nodes do not have any
dependencies and have a special `input` context, which does not have a
value computation function. Instead the value of the node is meant to
be set explicitly through some external event.

Input nodes have to be explicitly designated as such by setting the
`input` attribute to true. _See <<_attributes>> for more information
about node attributes_.

.Example: Setting Input Attribute
--------------------------------------------------
a -> b

# Designate `a` as an input node
:attribute(a, input, 1)
--------------------------------------------------

CAUTION: A compilation error is triggered if a node has a dependency
that is not reachable from any input node, however has at least one
dependency that is reachable from an input node. The error is not
signalled if all of the node's dependencies are unreachable from all
the input nodes.

=== Attributes ===

Attributes are arbitrary key value pairs associated with a node, which
control various compilation options of the node. These are set using
the special `:attribute` declaration. The `:attribute` declaration is
special in that it has a special syntax where not all its arguments
are interpreted as nodes.

The first argument is the node of which to set the attribute, the
second argument is the attribute key (not interpreted as a node) and
the last argument is the value, which is interpreted as a literal
value, not a node reference.

`:attribute` declarations may only appear at top-level and may not
appear in binding declarations or as arguments in functor nodes.

.Attribute Declaration Syntax
--------------------------------------------------
:attribute(node, attribute, value)
--------------------------------------------------

NOTE: The `attribute` key need not be a string, it may simply be an
identifier as it is not interpreted as a node.

IMPORTANT: As mentioned previously the `value` is treated as a literal
value, not a reference to the value of a node, since attributes do not
form part of the runtime node's state.

The `input` attribute has already been introduced. The following is a
listing of some attributes and a summary of their effect:

    `input`:: When set to true, designates a node as an input
    node. _See <<_input_nodes>>_.
    `no-coalesce`:: When set to true, prevents the node from being
    coalesced into other nodes. _See <<_coalescing>>_.
    `no-remove`:: When set to true, prevents the node from being
    removed.
    `public-name`:: The name with which the runtime node can be
    referenced from non-Tridash code.
    `macro`:: Indicates that a meta-node is a macro and should be
    invoked at compile-time. _See <<_macro_nodes>>_.
    `target-node`:: Sets the name of a meta-node to use as the value
    function, in the contexts of the bindings of the meta-node
    instance (as the source node) to its arguments (as the target
    nodes). _See <<_instances_as_targets>>_.
    `target-transform`:: The name of a meta-node to invoke if the
    meta-node, of which the attribute is set, appears as the target of
    a binding. _See <<_instances_as_targets>>_.

.Examples
--------------------------------------------------
:attribute(a, input, 1)
:attribute(a, public-name, "app-input")
--------------------------------------------------

=== Subnodes ===

Subnodes are nodes which reference a value, with a particular key, out
of a dictionary of values stored in another node, referred to as the
`parent` node.

Subnodes are referenced using the special `.` operator, which is also
an infix operator. The `parent` node appears on the left-hand side and
the key on the right-hand side. The key is treated as a literal
identifier.

.Syntax
--------------------------------------------------
<parent node>.<key identifier>
--------------------------------------------------

NOTE: The `.` operator is lexically special in that spaces are not
required to separate it from its operand.

NOTE: The `.` infix operator has precedence *1000* and *left*
associativity.

.Example
--------------------------------------------------
string-concat(
    person.first-name, <1>
    person.last-name   <2>
) -> full-name
--------------------------------------------------

<1> References the `first-name` subnode of node `person`.
<2> References the `last-name` subnode of node `person`.

An implicit two-way binding is established between the subnode and
parent node. The binding in the direction `parent -> subnode` has a
value function which extracts the subnode key from the dictionary
stored in `parent`. The binding in the reverse direction, `subnode ->
parent`, has a function which creates a dictionary with an entry which
has the subnode key as the key and the value of `subnode` as the
value. This allows a dictionary to be created in the `parent` node by
establishing an explicit binding with `subnode` as the
target. Multiple such bindings, with different subnodes of `parent`,
will result in a dictionary being created with an entry for each
subnode.

.Example: Creating Dictionaries
--------------------------------------------------
"John" -> person.first-name
"Smith" -> person.last-name
--------------------------------------------------

The value of a subnode is only evaluated when the value of its
dictionary entry is referenced. A subnode is not evaluated when only
the value of its parent node, which evaluates to the dictionary, is
referenced. _See <<_evaluation_strategy>>_. If a subnode fails to
evaluate to a value, it does not cause the parent node to fail to
evaluate to value. The parent node evaluates to a dictionary however
the dictionary entry, corresponding to the subnode, evaluates to a
failure. _See <<_failures>>_.

Accessing a non-existent entry, or accessing a subnode of a parent
node which does not evaluate to a dictionary will result in a failure.

== Meta-Nodes ==

A meta-node is a function, of one or more arguments, which evaluates
to a value. Meta-nodes are nodes, themselves, however without a
runtime node object. For the most part you can treat meta-nodes as
ordinary nodes, e.g. you can set attributes on meta-nodes using the
same `:attribute` declaration. Referencing the value of a meta-node
references the meta-node function.

Meta-node identifiers reside in the same namespace as that of ordinary
nodes, that is you cannot have both an ordinary node and meta-node
with identifier `f`. If there is a meta-node `f`, the declaration `f`
references the meta-node.

NOTE: Functor nodes with the meta-node as the operator are referred to
as instances of the meta-node.

TIP: Meta-nodes are referred to as meta-nodes, since they are nodes
which describe how to compute the value of other nodes, referred to as
their instances. Meta-nodes may also be macro-nodes which are
evaluated at compile-time, with the result being interpreted as
Tridash code.

=== Defining Meta-Nodes ===

Meta-nodes are defined using the special `:` definition operator which
has the following syntax:

.Definition Operator Syntax
--------------------------------------------------
name(arg1, arg2, ...) : {
    declarations*
}
--------------------------------------------------

The meta-node identifier, `name`, appears on the left-hand side of the
`:` operator followed by the comma-separated list of arguments in
parenthesis. Each item, at position _n_, of the argument list is the
identifier of the local node to which the _n_^th^ argument is bound.

CAUTION: Identifiers beginning with `:` are reserved for special
operators. A meta-node cannot have the same identifier as a special
operator. Currently no warning or compilation error is triggered
however that may change in a future release.

The body consists of a sequence of ordinary node declarations enclosed
in braces `{ ... }`. The braces are simply a way of grouping multiple
declarations into a single declaration, _See <<_node_lists, Node
Lists>>_. If the body of the meta-node contains just a single
declaration, the braces may be omitted.

The meta-node function returns value of the last node in the body.

.Example
--------------------------------------------------
# Evaluates to 1 + `n`
1+(n) : n + 1
--------------------------------------------------

.Factorial Example
--------------------------------------------------
# Computes the factorial of `n`

factorial(n) : {
    case (
         n > 1 : n * factorial(n - 1)
         1
    )
}
--------------------------------------------------

The following example demonstrates that the body can contain any valid
node declaration:

.Fibonacci Example
--------------------------------------------------
fib(n) : {
    fib(n - 1) -> fib1
    fib(n - 2) -> fib2

    case (
        n <= 1 : 1,
        fib1 + fib2
    )
}
--------------------------------------------------

IMPORTANT: Meta-nodes must be defined before they can occur as
operators in functors.

IMPORTANT: Meta-node bodies are only processed after all global (or
the scope in which the meta-node declaration occurs) declarations in
the same file have been processed. This allows a meta-node `g` to be
used within the body of another meta-node `f` even if the definition
of `g` appears after the definition of `f`. Effectively this allows
for mutual recursion.

==== Local Nodes ====

Nodes local to the meta-node's definition may only be referenced from
within the definition itself even if they have the same identifiers as
global nodes. Local nodes are created for each of the argument nodes.

A node reference, within the definition of a meta-node, primarily
refers to the local node. If there is no local node with that
identifier, it refers to the node in the enclosing scope. If the
enclosing scope does not contain a node with that identifier, the
scope's enclosing scope is searched until the global scope is
reached. If the node is not found in any enclosing scope a compilation
error is triggered.

Local nodes are created if they appear as the target of a binding,
whether implicit or explicit. This is the means by which local nodes,
storing intermediate results are created.

NOTE: The node creation rules inside meta-node definitions differ from
the node creation rules at the global scope.

TIP: A global node, with the same identifier as a local node, can be
referenced using the outer `..` operator.


.Example: Local Nodes
--------------------------------------------------
a + b -> x
x + y -> n

addx(n) : {
    # `n` refers to the local argument node `n`, not the global `n`
    # `x` refers to the global node `x`
    n + x
}
--------------------------------------------------

.Example: Meta-Nodes
--------------------------------------------------
1-(n) : n - 1

factorial(n) :
    case (
        # The 1- refers to the global 1- meta-node
        n > 1 : n * factorial(1-(n)),
        1
    )
--------------------------------------------------

.Example: Local nodes storing intermediate results
--------------------------------------------------
x + 1 -> next

factorial(n) :

    # A local node `next` is created since it appears as the target of
    # a binding. `next` does not refer to the global node of the same
    # name.

    n - 1 -> next

    case (
        n > 1 : n * factorial(next),
        1
    )
--------------------------------------------------

==== Self Node ====

The special `self` node is a local node which represents the
meta-node's value. This node can be used to set the value, returned by
the meta-node, using explicit bindings.

When an explicit binding to `self` is established, the meta-node no
longer returns the value of the last node in its definition.

IMPORTANT: A meta-node may not have more than a single context, see
<<_contexts, Contexts>>, as it is ambiguous which context's value
function to use as the meta-node function.

NOTE: In the absence of an explicit binding to `self`, the last node
in the meta-node's definition is implicitly bound to `self`.

.Example
--------------------------------------------------
factorial(n) : {
    n * factorial(n - 1) -> next
    case (n > 1 : next, 1) -> self
}
--------------------------------------------------

In the example, above, the value returned by the `factorial` meta-node
is set by an explicit binding to the `self` node (in the third
line). The meta-node no longer evaluates to the value of the last node
in the declaration list.

The `self` node is particularly useful for creating a dictionary of
values to which the meta-node evaluates to, see <<_subnodes,
Subnodes>>:

.Example: Creating Dictionaries
--------------------------------------------------
Person(first, last): {
    first -> self.first-name
    last -> self.last-name
}
--------------------------------------------------

==== Nested Meta-Nodes ====

The body of a meta-node can contain other meta-node definitions nested
inside it. These meta-nodes are local to the body, and can only be
used inside it, even if the same meta-node identifier appears in an
expression outside the body. If a meta-node with the same identifier
is already defined at global scope, the nested meta-node shadows it in
the scope of the body. This means that references to the meta-node
within the body refer to the nested meta-node and not the global node.

.Example: Factorial with Nested Tail-Recursive Helper Meta-Node
--------------------------------------------------
factorial(n) : {
    # `iter` is local to `factorial`
    iter(n, acc) : {
        case (
            n > 1 : iter(n - 1, n * acc),
            acc
        )
    }

    iter(n, 1)
}
--------------------------------------------------

=== Recursive Meta-Nodes ===

Meta-nodes may be recursive and mutually recursive, i.e. when a
meta-node `f` contains an instance of another meta-node `g` in its
definition, and `g` contains an instance of `f` in its definition.

Each call to a meta-node consumes an amount of stack space, if its
return value needs to be strictly evaluated to compute the return
value of the current meta-node. Each call increases the amount of
stack space used. If, however, the return value of a meta-node is
evaluated lazily, it does not increase the amount of stack space used,
since a 'thunk' is returned from the current function, thus freeing
the amount of stack space consumed by the current call, rather than
the final value.

Nodes are strictly evaluated only if it can be proved that their value
will always be required in order to compute the meta-node's return
value. If a node's value is only conditionally used, it is evaluated
lazily.

The following are examples of meta-nodes in which one or more of the
arguments are evaluated lazily:

- In the `if` meta-node, from the `core` module, the `if-true` and
`if-false` arguments are evaluated lazily since which one is actually
evaluated depends on the value of the first `test` argument. The
`test` argument is evaluated strictly as its value is required in
order to compute the return value of the meta-node.
+
--------------------------------------------------
if(test, if-true, if-false)
--------------------------------------------------

- In the `and` and `or` meta-nodes, from the `core` module, the first
  argument is strictly evaluated however the second is lazily
  evaluated as whether it is actually evaluated depends on the value
  of the first argument.
+
--------------------------------------------------
and(a, b)
or(a, b)
--------------------------------------------------

=== Outer Node References ===

The value of a node, declared in the global scope, can be referenced
from within a meta-node, either directly by its identifier, as
described in <<_local_nodes, Local Nodes>> or with the outer node
reference operator `..`. This is a special operator which takes a node
identifier as an argument and searches for a node with that
identifier, in each enclosing scope, starting from the scope in which
the meta-node is defined. The first node found is referenced.

NOTE: It is not necessary for the node to have been declared prior to
the meta-node definition, as meta-node definitions are only processed
after all declarations in the source file have been
processed. However, in general the node should be declared in the same
source file.

.Example
--------------------------------------------------
n

# ..(n) references the global node `n`
addn(n): n + ..(n)
--------------------------------------------------

Referenced outer nodes are treated as additional implicit or hidden
arguments, that are added to each instance of the meta-node. The
result of this is that any change in the referenced nodes, will
trigger a value update in each instance of the meta-node.

The previous example can be thought of as:

--------------------------------------------------
# Not valid syntax.

# Illustrates that outer node references are equivalent to additional
# arguments.

addn(n, ..(n)) : n + ..(n)
--------------------------------------------------

Thus the value of `n` is appended to the argument list of all
instances of `addn`, e.g. `addn(node)` becomes `addn(node, n)`.

Meta-nodes reference all outer nodes referenced by the meta-nodes
which are used in their body. In the previous example, if a meta-node
makes use of `addn`, it will also reference the node `n` declared in
the global scope.

IMPORTANT: Whilst the value of an outer-node can be referenced from
within the body of a meta-node, bindings with the node in target
position cannot be established, from within the body of the meta-node.

=== External Meta-Nodes ===

External meta-nodes are meta-nodes without a definition. They are used
to call external functions defined outside of Tridash code. The
special `:extern` declaration creates a meta-node without a
definition.

.Syntax
--------------------------------------------------
:extern(id)
--------------------------------------------------

`id` is the identifier of the meta-node to create.

An external definition for the meta-node has to be provided, and
linked with the generated code. In the JavaScript backend, instances
of the meta-node are compiled to a call to the JavaScript function
with the same name as the node identifier. If the `public-name`
attribute of the meta-node is set, a call to the JavaScript function
with the value of the attribute is generated instead.

=== Macro Nodes ===

A macro-node is a meta-node which is evaluated at compile-time and the
result is interpreted as a Tridash node declaration.

A meta-node is marked as a macro-node by setting the `macro` attribute
to true. Once set the meta-node's function will be evaluated on each
instance of the meta-node. The arguments passed to the function are
the corresponding node declarations in the functor node
declaration. Rather than the values of the arguments being passed to
the function, the raw argument node declarations are passed.

[TIP]
==================================================
Attributes are set on meta-nodes in the same way as they are set for
ordinary nodes. The `macro` attribute of a meta-node `f` is set to
'true', with the following declaration:

--------------------------------------------------
:attribute(f, macro, 1)
--------------------------------------------------
==================================================

Atom node declarations are represented by a special symbol type and
functor node declarations are represented as a list with the operator
in the first element of the list.

The return value of the meta-node function is processed as though it
is a parsed node declaration appearing in source code.

==== Literal Symbols ====

The special `:quote` operator returns its argument as a literal symbol
rather than a node declaration. The `'` macro from the core module is
the preferred shorthand for the `:quote` operator.

.Example
--------------------------------------------------
# This is interpreted as the literal symbol `x` rather than the node
# with identifier `x`.

:quote(x)

# The following is an shorthand for the above
'(x)
--------------------------------------------------

These can be used inside macro nodes to insert literal node or
operator names.

.Example: Definition of `'` macro
--------------------------------------------------
'(thing) :
    list(:quote(:quote), thing)

:attribute(', macro, 1)
--------------------------------------------------


==== Node References ====

Generally a macro-node expands to a declaration involving some other
meta-node. The meta-node might not be located in the same module, see
<<_modules,Modules>>, as the module in which the macro-node instance
occurs. Using the quote operator to generate a declaration involving
the meta-node may result in a compilation error, if the meta-node is
not present in the module in which the macro-node instance occurs, or
may result in a node declaration involving an entirely different
meta-node, if the module contains a node with the same identifier.

Node objects can be referenced directly with the node reference
operator, `&`. When the declaration returned by a macro-node contains
a raw node object, no node lookup is done and the raw node object is
used as though it has been returned by the node lookup. This is useful
in macros as the node is looked up once in the same module as the
macro-node's definition.


.Example: Definition of `<-` Macro
--------------------------------------------------
<-(target, src) :
    list(&(->), src, target)

:attribute(<-, macro, 1)
--------------------------------------------------

The `<-` macro function, in the example above, returns a functor
declaration where the operator is the node object `->`. When the
functor declaration is processed, the operator is taken to be the `->`
node, rather than the node with identifier `->` in the module in which
the instance is processed.

=== Instances as Targets ===

By default, a meta-node instance appearing as the target of a binding,
that is on the right hand side of the `->` operator, will result in a
compilation error. You may have noticed, however, that some meta-nodes
in the <<_core_module, `core`>> module, can also appear as the targets
of the binding, particularly <<meta-node-to-int, `to-int`>>,
<<meta-node-to-real, `to-real`>> and <<meta-node-to-string,
`to-string`>>. This is achieved by setting the `target-node` attribute.

The `target-node` attribute stores the identifier of the meta-node,
which is applied on the value of the meta-node instance, in order to
compute the value of the arguments. When the `target-node` attribute
is set, a binding is established between the meta-node instance, as
the dependency, and each argument node, as the observer. The function
of the binding context is set to the meta-node with the identifier
stored in the `target-node` attribute.

As an example consider a meta-node `f` with the `target-node`
attribute set to `g`. A declaration of the form:

--------------------------------------------------
x -> f(arg)
--------------------------------------------------

results in the following binding being established:

--------------------------------------------------
g(f(arg)) -> arg
--------------------------------------------------

This is useful for creating _invertable_ meta-nodes where instead of
computing a result given the values of the argument nodes, the values
of the argument nodes can be computed given the result. This is
achieved by binding to the meta-node instance, with the `target-node`
attribute set to the _inverse_ function.

The <<meta-node-to-int, `to-int`>> meta-node from the `core` module
has its `target-node` attribute set to `int`. Thus the binding `x ->
to-int(y)`, will result in the value of `y` being set to the value
`int(x)`, on changes in the value of `x`.

CAUTION: In order for the bindings to the argument nodes, to be
established, the `:attribute` declaration which sets the `target-node`
attribute must occur before the first instance of the
meta-node, however after the meta-node is defined.

=== Target Node Transforms ===

The `target-node` attribute allows for a binding of a simple function
to be established in the reverse direction, from the meta-node
instance to its argument. However, it lacks the functionality for
setting a different function for each argument or generating more
complex binding declarations.

The `target-transform` attribute allows another node to be set as the
function which is called whenever an instance of the meta-node appears
as the target of a binding. The function is called with two arguments:
the 'source' node of the binding and the functor declaration, which
appears as the 'target' of the binding.

The `target-transform` function should return a declaration which is
processed instead of the binding declaration. The result is processed
as though it appears in top-level and unlike with a macro-node, the
result is not substituted directly in the place of the meta-node
instance.

NOTE: The 'source' argument is not necessarily the actual source node
declaration but is generally an atom node with a randomly generated
identifier which should serve as the source node for the binding
declarations generated by the `target-transform` node.

== Modules ==

Modules provide a means of avoiding name collisions between nodes. A
module is a namespace which contains all global nodes, including
`meta-nodes`, created in it. A node with identifier `x` in a module
`m1` is distinct from a node with the same identifier `x` in another
module `m2`.

=== Creating Modules ===

Each new node, that is created as a result of processing a declaration
in the source file, is added to the current module. Initially the
current module is a nameless `init` module until it is changed
explicitly.

The current module is changed with the special `:module` operator,
which takes the identifier of the module as its only argument. If
there is no such module a new module is created.

.Example
--------------------------------------------------
# Change to module with identifier `mod1`
:module(mod1)

# Nodes `a` and `b` added to `mod1`
a -> b

# Change to module with identifier `mod2`
:module(mod2)

# Nodes `a` and `b` added to `mod2`
# Distinct nodes from nodes `a` and `b` in `mod1`
a -> b
--------------------------------------------------

NOTE: Module identifiers reside in a different namespace from node
identifiers, thus there is no risk of collision between a node and
module with the same identifier, unless a node for the module is added
to the module containing the node.

NOTE: Modules reside in a single global, flat namespace. Hierarchical
relations between modules have to be 'faked' with a separator such as
`/`, e.g. `module/submodule`.

=== Referencing Nodes in Different Modules ===

There are two ways to reference a node in a another module, different
from the current module. One way is to create a 'pseudo-node' for the
module in the current module. Nodes in the module can then be
referenced as subnodes of the module's 'pseudo-node'.

==== Module Pseudo-Nodes ====

The special `:use` operator creates pseudo-nodes for the modules
passed as arguments. The pseudo-nodes are created with the same
identifiers as the modules.

NOTE: Module pseudo-nodes are referred to as such, since syntactically
they appear the same as any other node, however the value of a module
pseudo-node cannot be referenced nor can bindings involving it be
established.

.Syntax
--------------------------------------------------
:use(mod1, mod2, ...)
--------------------------------------------------

CAUTION: An error is signalled if a node with the same identifier as
the module already exists in the current module.

Nodes from the 'used' modules can then be referenced as subnodes of
the module pseudo nodes.

.Example
--------------------------------------------------
:module(mod1)

a -> b

:module(mod2)
:use(mod1)

# Reference node `b` from module `mod1`
mod1.b -> b
x -> mod1.b
--------------------------------------------------

Meta-nodes from a different module can be also referenced as subnodes
of the module pseudo-node.

.Example
--------------------------------------------------
:module(mod1)

add(x, y) : x + y

:module(mod2)
:use(mod1)

# Use the `add` meta-node from module `mod1`
mod1.add(a, b) -> c
--------------------------------------------------

TIP: Nodes referenced from other modules, can appear both as
dependencies or observers of bindings.

IMPORTANT: Referencing a subnode of a module pseudo-node does not
result in the automatic creation of a node in that module. The result
is a compilation error, if the node does not already exist in the
module.

A pseudo-node with a different identifier, from the identifier of the
module, can be created using the special `:alias` operator. This is
useful for when the module identifier is too long to type out
repeatedly, or there is already a node, in the current module, with
the same identifier.

the `:alias` operator takes two arguments, the identifier of the
module and the name of the pseudo-node to create in the current
module:

--------------------------------------------------
:alias(module-name, pseudo-node-name)
--------------------------------------------------

The above examples can be rewritten using `:alias` declarations:

.Example
--------------------------------------------------
:module(mod1)

a -> b

:module(mod2)
:alias(mod1, m1)

# Reference node `b` from module `mod1`
m1.b -> b
x -> m1.b
--------------------------------------------------

.Example
--------------------------------------------------
:module(mod1)

add(x, y) : x + y

:module(mod2)
:alias(mod1, m1)

# Use the `add` meta-node from module `mod1`
m1.add(a, b) -> c
--------------------------------------------------

==== Importing Nodes ====

The second approach to referencing a node, residing in another module,
is to add it directly to the current module. With this approach there
is no need to reference the node as a subnode of a module
pseudo-node. This is referred to as 'importing' the node and is
achieved using the `:import` operator.

The `:import` operator adds the identifiers of nodes, residing in
another module, to the current module. The result is that the node can
be referenced directly by its identifier, as though it were declared
in the current module.

The `:import` operator has two forms:

    - A short form that 'imports' all the nodes 'exported' from
      another module. Takes the module identifier as its only
      argument.
    - A short form that can be used to 'import' specific nodes. The
      first argument is the module identifier, the following arguments
      are the identifiers of the nodes to 'import'

.Syntax
--------------------------------------------------
# Short form: Import all nodes from `module`
:import(module)

# Long form: Import only the nodes listed in the arguments after the
# module identifier.
:import(module, node1, node2, ...)
--------------------------------------------------

.Example: Long form
--------------------------------------------------
:module(mod1)

a -> b

:module(mod2)

# Import node `b` from `mod1`
:import(mod1, b)

# Node `b` is the same `b` as in `mod1`
b -> a
x -> b
--------------------------------------------------

The short form only imports those nodes which are explicitly
'exported' from the module. Nodes are explicitly exported from the
current module with the `:export` operator which simply takes the
identifiers of the nodes to 'export' as arguments.

.Syntax
--------------------------------------------------
:export(node1, node2, ...)
--------------------------------------------------

Each `:export` declaration adds (does not replace) nodes, in the
arguments, to the exported nodes of the current module.

.Example: `:export` and short form `:import`
--------------------------------------------------
:module(mod1)

a -> b

# Export node `b`
:export(b)

:module(mod2)
# Import all nodes exported from `mod1`
:import(mod1)

# Node `b` is the same `b` as in `mod1`
b -> a
x -> b
--------------------------------------------------

.Meta-node Example: `:export` and short form `:import`
--------------------------------------------------
:module(mod1)

add(x, y) : x + y

:export(add)

:module(mod2)
:import(mod1)

# Use the `add` meta-node from module `mod1`
add(a, b) -> c
--------------------------------------------------

A side effect of `:import` is that if an imported node, whether
imported by the long or short form of `:import`, is registered as an
infix operator in the module, from which it is being imported, it's
entry in the module's operator table is copied over to the current
module. This allows the operator to be placed in infix position, in
the current module.

==== Direct References ====

It may be necessary to reference a node in another module without
creating a pseudo-node, for its module, and without importing it in
the current module. The special `:in` operator directly references a
node in another module by the module and node identifiers.

.Syntax
--------------------------------------------------
:in(module-id, node-id)
--------------------------------------------------

The first argument is the identifier of the module containing the
node, and the second argument is the identifier of the node.

IMPORTANT: `module-id` is the identifier of the module itself, and not
the identifier of a module pseudo-node.

.Example: `:in` Operator
--------------------------------------------------
:module(mod1)

a -> b

:module(mod2)

# Reference node `b` in `mod1` directly
:in(mod1, b) -> a
x -> :in(mod1, b)
--------------------------------------------------

.Example: `:in` Operator
--------------------------------------------------
:module(mod1)

add(x, y) : x + y

:module(mod2)

# Use the `add` meta-node from module `mod1`
(:in(mod1, add))(a, b) -> c
--------------------------------------------------


=== Operator Table ===

Each module may register a number of node identifiers as infix
operators. This means that those identifiers may appear in infix
position in declarations parsed while the module is the current
module. The module's 'operator table' stores the identifier,
precedence and associativity of each infix operator. _See <<__functors,
Functors>> for more information about infix operators, operator
precedence and associativity_.

Initially the operator table of each module contains a single entry
which is the special entry for function application. The precedence of
function application controls whether an expression is treated as the
operator of a functor or the operand of an infix expression.

The precedence of function application is set to `900`. This value
cannot be changed.

.Example: Precedence of Function Application
--------------------------------------------------
# If `.` has a higher precedence than function application, the
# following is parsed to: ((. m1 add) a b)

# If `.` has a lower precedence than function application, the
# following is parsed to: (. m1 (add a b))

m1.add(a, b)
--------------------------------------------------

==== Registering Infix Operators ====

New infix operators can be registered using the special `:op`
declaration. This declaration modifies the operator table of the
current module.

.Syntax
--------------------------------------------------
:op(identifier, precedence [, left | right])
--------------------------------------------------

The first argument is the node identifier to register as an infix
operator. The second argument is the precedence as an integer
value. The third argument specifies the associativity. This is either
the identifier `left` or `right` for 'left' or 'right'
associativity. If the third argument is omitted, 'left' associativity
is assumed.

NOTE: The identifier does not have to name a node or meta-node that
exists at the time the `:op` declaration is processed. The table only
stores the identifier for syntactic transformations, no information
about the actual node is stored.

An `:op` declaration adds an entry to the current module's operator
table if it does not already contain an entry for the identifier. If
the table already contains an entry for the identifier, the the
'precedence' and 'associativity' values of the existing entry are
replaced with those given in the arguments to the `:op` declaration.

NOTE: The 'precedence' and 'associativity' of all operators can be
changed, with the exception of 'function application'.

When a node is imported into the current module and there is an entry,
for the node's identifier, in the operator table of the module, from
which the node is being imported, the entry is copied over into the
current module's operator table, replacing any existing entries for the
identifier if any.

.Example: `+` infix operator from `core` module
--------------------------------------------------
# Register `+` as infix operator
:op(+, 100, left)

# Now `+` can appear in infix position
a + b

# It can also still appear in prefix position
+(a, b)
--------------------------------------------------
