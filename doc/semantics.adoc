== Nodes ==

Semantically a Tridash program is composed of a set of stateful
components called nodes, with the node's state consisting of its
value.

Each node has a set of _dependency_ nodes. A change in the state of at
least one of the dependency nodes causes the node to recompute its own
value. The node is said to be an _observer_ of its dependency nodes,
as it actively observers and response to changes in their
state. Similarly, each node has a set of _observer_ nodes which it
notifies whenever its own value changes.

This _dependency_ -- _observer_ relation is referred to as a binding.

.Glossary
--
dependency:: A node `a` is said to be a _dependency_ of node `b` if a
change in the value of `a` triggers a change in the value of `b`.

observer:: A node `a` is said to be an _observer_ of node `b` if a
change in the value of `b` triggers a change in the value of `a`.

binding:: A _binding_ is a relation between two nodes `a` and `b`, in
which one node `a` is a _dependency_ of the other `b`, and likewise
the other node `b` is its _observer_.

ancestor:: A node `a` is said to be an _ancestor_ of a node `b` if `a`
is a _dependency_ of `b` or it is an _ancestor_ of a _dependency_ of `b`.

successor:: A node `a` is said to be a _successor_ of a node `b` if
`a` is an _observer_ of `b` or it is a successor of an _observer_ of
`b`.
--

=== Declaring Nodes ===

Nodes are created on the first reference, that is when their
identifier appears in source code. This could either be a declaration
consisting of the identifier itself or a functor node declaration of
which the node is an argument.

IMPORTANT: The `self` identifier is reserved as an alias for other
nodes, see <<_meta_nodes, Meta-Nodes>>

.Examples
--------------------------------------------------
# Results in the creation of node `name`
name

# Results in the creation of nodes `a`, `b`
a -> b

# Results in the creation of nodes `x`, `y` and `f(x, y)`
f(x, y)
--------------------------------------------------

This allows for a relaxed ordering of declarations. A node's
definition need not be complete in order for it to be referenced as an
argument.

Notice that in the last example, above, a node `f(x, y)` was
created. This node corresponds to the functor node declaration, thus
functors, with the exception of a few special declarations, are nodes
themselves. From now on a functor node declaration refers only to
syntactic functor declarations in which the operator refers to a
function. Declarations in which the operator does not refer to a
function are referred to as special declarations.

NOTE: Operators which correspond to functions, such as `f` in the
example above are referred to as meta-nodes and the functor
declaration as an instance of the meta-node. See <<_meta_nodes,
Meta-Nodes>>.

NOTE: Nodes are also created corresponding to functors written in
infix form, e.g. for the functor `a + b`, the node `+(a, b)` is
created.

A node was not created corresponding to the `a -> b`. This is the bind
declaration which is treated rather specially. The `->` is not a
meta-node, that is it does not compute a value, but a special
operator.

=== Declaring Bindings ===

A binding between two nodes is declared with the special bind operator
`->`.

--------------------------------------------------
a -> b
--------------------------------------------------

The above declares `b` an observer of `a` and likewise `a` a
dependency of `b`. The result is that a change in the value of `a`
will trigger a change in the value of `b`. This is an example of a
simple binding, since the value of `b` is simply set to the value of
`a`.

NOTE: In an explicit binding declaration the dependency, i.e. the
left-hand side of the `->` operator is referred to as the source node,
and the observer, i.e. the right-hand side, is referred to as the
target node.

NOTE: The bind operator is also registered as an infix operator with
precedence *10* and *right* associativity.

TIP: The `->` operator is in the form of an arrow which indicates the
direction of data-flow, from the node on the left to the node on the
right.

Functional bindings involve a function of 1 or more argument
nodes. Function bindings are created implicitly in functor node
declarations, with each argument node added as a dependency of the
functor node. A change the value of at least one argument node results
in the value of the functor being updated to the result of
reevaluating the expression with the new values of the argument nodes.

.Example
--------------------------------------------------
a + b
--------------------------------------------------

In the example, above, a functor node `+(a, b)` was created with the
arguments `a` and `b` implicitly added as dependencies of `+(a, b)`. A
change in either `a` or `b` will result in the value of `+(a, b)`
being recomputed.


=== Propagation of Changes ===

As emphasized in the previous sections, changes in the value of a node
are propagated to its observer nodes. The new value is propagated to
each of the observers simultaneously. Each observer then proceeds to
recompute its own value in parallel with the other observers.

.Example
--------------------------------------------------
a -> b
a + n -> c
a + 1 -> d
--------------------------------------------------

Node `a` has three observers: `b`, `+(a, n)`, `+(a, 1)`. Each of `b`,
`+(a, n)` and `+(a, 1)` receives the new value of `a` and immediately
begins computing its new value. There is no strict sequential ordering
of the value updating of the observer nodes, the following orderings
are all possible:

    - `b`, `+(a, n)`, `+(a, 1)`
    - `+(a, n)`, `b`, `+(a, 1)`
    - `+(a, 1)`, `+(a, n)`, `b`

Other orderings, including interleaved orderings, are also possible or
it may be that the values of all the observers are updated in
parallel.

It is important to note the semantics when nodes share a common
observer and the change in value of each node is triggered by a common
ancestor node of each node. A node is said to be _dirtied_ if either
its value has changed, or at least one of its dependency nodes has
been _dirtied_. If a node is dirtied, all its observers are dirtied,
and likewise their observers are dirtied and so on. A node with
multiple dependencies will only recompute its value when it receives a
value change notification from each of its dirtied dependency
nodes. Thus there is no intermediate value where the node's value is
recomputed before all the dependency nodes have recomputed their
values.

IMPORTANT: This is only the case when the changes in each of the
dependency nodes are triggered by a change in a common ancestor
node. These semantics do no apply when the changes in the dependency
nodes are not triggered by a change in a common ancestor node but by
multiple simultaneous changes in an ancestor of each dependency,
unless the changes in each ancestor are the setting of the initial
values, in which case it is treated as though they have been triggered
by a single common ancestor. See <<_literal_bindings, Literal
Bindings>>.

.Example
--------------------------------------------------
a -> b
a + 1 -> c

b + c -> out
--------------------------------------------------

In the example, above, `a` is a common ancestor of both dependency
nodes `b` and `c` of node `+(b, c)`. A change in `a` will _dirty_
nodes `a`, `b`, `+(a, 1)`, `c`, `+(b, c)` and `out`. The value of
`+(b, c)` will only be recomputed when the values of both `b` and `c`
have been recomputed.

If `b` and `c` did not have the common ancestor `a`, the value of
`+(b, c)` would be computed on each change in value of either `b` or
`c`, regardless of whether the changes in values of `a` and `b` are
triggered simultaneously or not.

=== Contexts ===

The function which computes a node's value is controlled by its
context at the moment in time. The node context stores information
about the function, with which, the node's value is computed and which
of the dependency nodes are operands to the function.

Contexts are created whenever a binding between two nodes is
established.

The most simple value function is the passthrough, created when a
simple binding between two nodes is established, in which the node's
value is simply set to the value of its dependency node.

.Passthrough Example
--------------------------------------------------
# `b` is set to the value of `a` whenever it changes

a -> b.
--------------------------------------------------

Contexts with more complex functions, of more than one operand, are
created whenever a functor node, in which the operator is a
_meta-node_, is declared. A context is created, with the operator as
the context function and the arguments as the context operands.

.Functor Node Example
--------------------------------------------------
# A functor node `+(a, b)` is created with a `+` context.
# `a` and `b` are added to the operands of the plus context.

a + b
--------------------------------------------------

A node can have more than one context. A context is _activated_
whenever the value of one of its operand nodes changes.

.Multiple Context Example
--------------------------------------------------
a -> x
b -> x
c -> x
--------------------------------------------------

When the value of `a` changes, the `a` context of `x` is activated and
the value of `x` is set to the value of `a`. Similarly when `b` or
`c`'s value changes, the `b` or `c` context is activated,
respectively, and `x`'s value is set to the value of `b` or `c`,
respectively.

[IMPORTANT]
==================================================
It is an error for two or more contexts of a single to be activated at
the same time. This occurs when either both contexts have a common
operand or an operand from one context shares a common ancestor with
an operand from the other context.

.Example 1
--------------------------------------------------
# Node `a` is a dependency of `b`
# Node `a` is a dependency of `+(a, c)`
# Both `b` and `+(a, c)` are dependencies of `x`

a -> b
b -> x

a + c -> x
--------------------------------------------------

In the example, above, node `a` is a dependency node of `b` which is
an operand of the `b` context of `x`. However, node `a` is also a
dependency of node `+(a, c)` (`a + c`), which is an operand of the
`+(a, c)` context of `x`. A change in the value of `a` would trigger a
change in the value of both `b` and `+(a, c)` thus it is ambiguous to
which value `b` should be set, the value of `b` or the value of `+(a,
c)`.

Structure checking is performed at compile-time, thus the above
example, and all such scenarios, would result in a compilation error
along the lines: `Semantic Error: Node x has multiple contexts
activated by a single common ancestor`.
==================================================

==== Two-Way Bindings ====

A dependency of a node may also be an observer of the same node. This
allows for a two-way binding in which data may flow from either
direction. In this case only the observer nodes which are not also
operands of the node's current context are notified of a change in the
node's value.

.Example
--------------------------------------------------
# A two-way binding is established between `a` and `b`
a -> b
b -> a

a -> c

d -> a
--------------------------------------------------

In the above example a change both `b` and `c`, which are observers of
`a`, will be notified of a change in the value of `a` triggered by a
change in the value of `d`. This will trigger a change in the value of
`b` however `a` will not be notified of this change as the change was
triggered by `a`, itself.

In the case of a change in the value of `a` triggered by a change in
the value of `b`, only the observer `c` of `a` will be notified of the
change.

[IMPORTANT]
==================================================
Cycles, other than two-way bindings between a pair of nodes, will
result in a compilation error.

.Example
--------------------------------------------------
a + 1 -> b
b -> a
--------------------------------------------------
==================================================


==== Literal Bindings ====

A binding in which the dependency is a literal value, is interpreted
as setting the initial value of a node. A special `init` context is
created, which has no operands and simply the literal value as its
function.

Initial values are set on the launch of the application, and are
treated as an ordinary value change from the value `null` to the
initial value. The initial active context of the node is the `init`
context.

.Examples
--------------------------------------------------
0 -> counter
"hello" -> message
10.5 -> threshold
--------------------------------------------------

IMPORTANT: The setting of the initial values of each node in the
graph, is treated as having been triggered by a single common ancestor
node. See <<_propagation_of_changes, Propagation of Changes>> for the
implications of this.

=== Conditionally Active Bindings ===

A binding declaration `a -> b` can, itself, be treated as a node, to which an
explicit binding can be established with the binding node as the
target.

--------------------------------------------------
c -> (a -> b)
--------------------------------------------------

The result of this declaration is that the binding `a -> b` is only
active if the condition node `c` evaluates to a true value. If `c`
evaluates to false, it can be considered that there is no binding
between `a` and `b` or that the binding is _inactive_. The implication
of the binding, `a -> b`, being _inactive_ is that no changes in
values are propagated from `a` to `b`, i.e. changes in the value of
`a`, will not trigger value changes in `b` or any of its successor
nodes.

A binding declaration, with a binding node as the target, changes the
function of the context of the binding to cease the current
propagation of values if the value of the condition node is false. The
binding node `a -> b` (`->(a, b))` in prefix notation), is added as a
dependency of `b` and as an operand of the context corresponding to
the binding `a -> b`. The binding node is itself an observer of `c`
with a simple passthrough function. This allows you to reference the
'status' of the binding by referencing the binding node, `a -> b`.

.Example: Simple Validation
--------------------------------------------------
# Validate that `i` has a value > 0
# Propagate value of `i` to `j`

i > 0 -> (i -> j)

# Perform some computation with `j` which is guaranteed to only be
# updated to the value of `i` if it is > 0.
...
--------------------------------------------------

TIP: The bind `->` operator has 'right' associativity, thus the
parenthesis in `c -> (a -> b)` can be omitted: `c -> a -> b`.

=== Input Nodes ===

Input nodes are the nodes which receive the application input, which
could be the value entered in a text field of the user interface (UI),
data received from the network, etc. Input nodes do not have any
dependencies and have a special `input` context, which does not have a
value computation function. Instead the value of the node is meant to
be set explicitly through some external event.

Input nodes have to be explicitly designated as such by setting the
`input` attribute to true. (see <<_attributes,Attributes>> for more
information about node attributes).

.Example: Setting Input Attribute
--------------------------------------------------
a -> b

# Designate `a` as an input node
:attribute(a, input, 1)
--------------------------------------------------

CAUTION: A compilation error is signalled if a node has a dependency
that is not reachable from any input node, however has at least one
dependency that is reachable from an input node. The error is not
signalled if all of the node's dependencies are unreachable from all
the input nodes.

=== Attributes ===

Attributes are arbitrary key value pairs associated with a node, which
control various compilation options of the node. These are set using
the special `:attribute` declaration. The `:attribute` declaration is
special in that it has a special syntax where not all its arguments
are interpreted as nodes.

The first argument is the node of which to set the attribute, the
second value is the attribute key (not interpreted as a node) and the
last attribute is the value, which must be a literal value. `

:attribute` declarations may only appear at top-level and may not
appear in binding declarations or as arguments in functor nodes.

.Attribute Declaration Syntax
--------------------------------------------------
:attribute(node, attribute, value)
--------------------------------------------------

NOTE: The `attribute` key need not be a string, it may simply be an
identifier as it is not interpreted as a node.

IMPORTANT: As mentioned previously the `value` must be a literal value
and may not reference the value of a node, since attributes do not
form part of the runtime node's state.

The `input` attribute has already been introduced. The following is a
listing of some attributes an a summary of their effect:

    `input`:: When set to true, designates a node as an input
    node. See <<_input_nodes,Input Nodes>>.
    `no-coalesce`:: When set to true, prevents the node from being
    coalesced into other nodes. See <<_coalescing, Coalescing>>.
    `no-remove`:: When set to true, prevents the node from being
    removed.
    `public-name`:: The name with which the runtime node can be
    referenced from non-Tridash code.
    `target-node`:: Sets the name of a meta-node to use as the value
    function, in the contexts, other than the context of the meta-node
    itself, of a meta-node instance.

.Examples
--------------------------------------------------
:attribute(a, input, 1)
:attribute(a, public-name, "app-input")
--------------------------------------------------

=== Subnodes ===

Subnodes are nodes which reference a value, with a particular key, out
of a dictionary of values stored in another node, referred to as the
`parent` node.

Subnodes are referenced using the special `.` operator, which is also
an infix operator. The `parent` node appears on the left-hand side and
the key on the right-hand side. The key is not treated as a raw
identifier, instead the identifier appearing on the right-hand side is
treated as the raw key identifier.

.Syntax
--------------------------------------------------
<parent node>.<key identifier>
--------------------------------------------------

TIP: The `.` operator is lexically special in that spaces are not
required to separate it from its operand.

NOTE: The `.` infix operator has precedence *1000* and *left*
associativity.

.Example
--------------------------------------------------
person.first-name + person.last-name -> full-name
--------------------------------------------------

There are two subnode references: the first references the
`first-name` subnode of the parent node `person` and the second
references the `last-name` subnode of `person`.

An implicit two-way binding is established between the subnode and
parent node. The binding in the direction +parent -> subnode+ has a
value function which extracts the subnode key from the dictionary
stored in `parent`. The binding in the reverse direction, +subnode ->
parent+, has a function which creates a dictionary with an entry which
has the subnode key as the key and the value of `subnode` as the
value. This allows a dictionary to be created in the `parent` node by
establishing an explicit binding with `subnode` as the
target. Multiple such bindings, with different subnodes of `parent`,
will result in a dictionary being created with an entry for each
subnode.

.Example: Creating Dictionaries
--------------------------------------------------
"John" -> person.first-name
"Smith" -> person.last-name
--------------------------------------------------

== Meta-Nodes ==

A meta-node is a function, of one or more arguments, which evaluates
to a value. Meta-nodes are nodes, themselves, however no runtime node
is created for meta-nodes. For the most part you can treat meta-nodes
as ordinary nodes, e.g. you can set attributes on meta-nodes using the
same `:attribute` declaration. However, as of yet you cannot reference
the value of a meta-node. Referencing the value of a meta-node will
result in a compilation error.

Meta-node identifiers reside in the same namespace as that of ordinary
nodes, that is you cannot have both an ordinary node and meta-node
with identifier `f`. If there is a meta-node `f`, the declaration `f`
references the meta-node.

NOTE: Functor nodes with the meta-node as the operator are referred to
as instances of the meta-node.

TIP: Meta-nodes are referred to as meta-nodes, since they are nodes
which describe how to compute the value of other nodes, referred to as
their instances. Meta-nodes may also be macros, such as the builtin
`?->` and `case` meta-nodes in the `core` module. However, at present
there is no functionality for defining macros in Tridash code.

=== Defining Meta-Nodes ===

Meta-nodes are defined using the special `:` definition operator which
has the following syntax:

.Definition Operator Syntax
--------------------------------------------------
name(arg1, arg2, ...) : {
    declarations*
}
--------------------------------------------------

The left-hand side of the `:` operator contains the meta-node
identifier, `name`, followed by the comma-separated list of arguments
in parenthesis. Each item, at position _n_, of the argument list is
the identifier of the local node to which the _n_^th^ argument is
bound.

CAUTION: Identifiers beginning with `:` are reserved for special
operators. A meta-node cannot have the same identifier as a special
operator, including the bind `->` and outer `..` operators.

The body consists of a sequence of ordinary node declarations enclosed
in braces `{ ... }`. The braces are simply a way of grouping multiple
declarations into a single declaration. If braces appear as an operand
in a functor, it is as if they are replaced by the last declaration in
the list, and the remaining declarations are extracted to the
top-level. If the body of the meta-node contains just a single
declaration, the braces may be omitted.

Functor expressions with the meta-node as an operator evaluate to the
value of the last node in the body.

.Example
--------------------------------------------------
# Evaluates to 1 + `n`
1+(n) : n + 1
--------------------------------------------------

.Factorial Example
--------------------------------------------------
# Computes the factorial of `n`

factorial(n) : {
    case (
         n > 1 : n * factorial(n - 1)
         1
    )
}
--------------------------------------------------

The following example demonstrates that the body can contain any valid
node declaration:

.Fibonacci Example
--------------------------------------------------
fib(n) : {
    fib(n - 1) -> fib1
    fib(n - 2) -> fib2

    case (
        n <= 1 : 1,
        fib1 + fib2
    )
}
--------------------------------------------------

IMPORTANT: Meta-nodes must be defined before they are used in the same
scope as the scope in which the meta-node declaration occurs. That is,
a declaration involving the meta-node `f` as an operator must occur
after the definition of `f`. A meta-node `f` can, however, be used in
the body of another meta-node `g`, even if its definition precedes
`f`, i.e. mutual recursion is possible.

==== Local Nodes ====

Nodes created within the body of a meta-node are local to the
meta-node. Local nodes can only be referenced from within the
meta-node's body even if they have the same identifiers as nodes
declared in the global scope.

IMPORTANT: A local node is always created on the first reference
inside the meta-node's body even if a global with the same identifier
has already been declared. Global nodes can be referenced using the
outer `..` operator.

Meta-nodes referenced from within the body, i.e. in a functor
expression of which the meta-node is an operator, always refer to the
meta-node defined at global scope unless a meta-node, with the same
identifier, is defined inside the body.

.Example: Local Nodes
--------------------------------------------------
a + b -> x

addx(n) : {
    # Refers to x that is local to the body
    # Not the x at global scope.
    n + x
}
--------------------------------------------------

.Example: Meta-Nodes
--------------------------------------------------
1-(n) : n - 1

factorial(n) :
    case (
        # The 1- refers to the global 1- meta-node
        n > 1 : n * factorial(1-(n)),
        1
    )
--------------------------------------------------

==== Self Node ====

The special `self` node is a local node which is as an alias for the
meta-node. This node can be used to set the value, to which the
meta-node evaluates to, using explicit bindings.

Inside the body of a meta-node it is permissible to establish an
explicit binding with the meta-node as an observer. When an explicit
binding to the meta-node is established, the meta-node no longer
evaluates to the value of the last node in its body.

CAUTION: Whilst an explicit binding with the meta-node as an observer
can be established, the meta-node cannot be a dependency of any node
in its body.

IMPORTANT: A meta-node may not have more than a single context, see
<<_contexts, Contexts>>, as it is ambiguous which context's value
function to use as the meta-node function.

NOTE: In the absence of an explicit binding to the meta-node, the last
declaration in its body is implicitly bound to the meta-node.

.Example
--------------------------------------------------
factorial(n) : {
    case (n > 1 : next, 1) -> self
    n * factorial(n - 1) -> next
}
--------------------------------------------------

In the example, above, the value of the `factorial` meta-node is set
by an explicit binding to the `self` node (in the second line). The
meta-node no longer evaluates to the value of the last node in the
declaration list.

[NOTE]
==================================================
`self` is merely an alias for the meta-node, in which the declaration
occurs. The binding to self, in the second line of the previous
example, may have been declared as follows:

--------------------------------------------------
case (n > 1 : next, 1) -> factorial
--------------------------------------------------
==================================================

The `self` node is particularly useful for creating a dictionary of
values to which the meta-node evaluates to, see <<_subnodes,
Subnodes>>:

.Example: Creating Dictionaries
--------------------------------------------------
Person(first, last): {
    first -> self.first-name
    last -> self.last-name
}
--------------------------------------------------

==== Nested Meta-Nodes ====

The body of a meta-node can contain other meta-node definitions nested
inside it. These meta-nodes are local to the body, and can only be
used inside it, even if the same meta-node identifier is used in an
expression outside the body. If a meta-node with the same identifier
is already defined at global scope, the nested meta-node shadows it in
the scope of the body. This means that references to the meta-node
within the body refer to the nested meta-node and not the global node.

.Example: Factorial with Nested Tail-Recursive Helper Meta-Node
--------------------------------------------------
factorial(n) : {
    # `iter` is local to `factorial`
    iter(n, acc) : {
        case (
            n > 1 : iter(n - 1, n * acc),
            acc
        )
    }

    iter(n, 1)
}
--------------------------------------------------

=== Recursive Meta-Nodes ===

Meta-nodes may be recursive and mutually recursive, i.e. when a
meta-node `f` contains an instance of another meta-node `g` in its
definition, and `g` contains an instance of `f` in its definition.

In the case of tail-recursive meta-nodes, a meta-node in contains an
instance of itself in tail position, the meta-node function is
guaranteed to consume constant `O(1)` space, regardless of the number
of recursive calls.

A meta-node instance is considered to be in tail position if it
satisfies one of the following:

    - Is the last expression in the meta-node definition.
    - Is an `if-true` or `if-false` argument of the `if` meta-node,
      from the `core` module, which is itself in tail position.
    - Is an argument of a `and` or `or` meta-node, from the `core`
      module, which is itself in tail position.

All instances appearing in tail-position or appearing as the
`if-true`, `if-false` arguments to the `if` meta-node, from the `core`
module,

NOTE: Tail Call Elimination for all instances of a given meta-node,
can be achieved by setting the `async` attribute of the meta-node to
true. However this feature is still highly experimental and not
properly tested.

=== Outer Node References ===

The value of a node, declared in the global scope, can be referenced
from within a meta-node with the outer node reference operator
`..`. This is a special operator which takes a node identifier as an
argument and searches for a node with that identifier, in each
enclosing scope, starting with the scope in which the meta-node is
defined. The first node found is referenced.

CAUTION: If no node with that identifier is found in any enclosing
scope, a compilation error is signalled.

NOTE: It is not necessary for the node to have been declared prior to
the meta-node definition, as meta-node definitions are only processed
after all declarations in the source file have been
processed. However, in general the node should be declared in the same
source file.

.Example
--------------------------------------------------
x

# ..(x) references the global x
addx(n): n + ..(x)
--------------------------------------------------

Referenced outer nodes are treated of as additional implicit or hidden
arguments, that are added to each instance of the meta-node. The
result of this is that any change in the referenced nodes, will
trigger a value update in each instance of the meta-node.

The previous example can be thought of as:

--------------------------------------------------
# Not valid syntax.

# Simply used to illustrate that outer node references are equivalent
# to additional arguments.

addx(n, ..(x)) : n + ..(x)
--------------------------------------------------

Thus the value of `x` is appended to the argument list of all
instances of `addx`, e.g. `addx(node)` is equivalent to `addx(node,
x)`.

Meta-nodes reference all outer nodes referenced by the meta-nodes
which are used in their body. In the previous example, if a meta-node
makes use of `addx`, it will also reference the node `x` declared in
the global scope.

IMPORTANT: Whilst the value of an outer-node can be referenced from
within the body of a meta-node, bindings involving the node cannot be
established, from within the body of the meta-node.

=== External Meta-Nodes ===

External meta-nodes are meta-nodes without a definition. They are used
to call functions defined externally from within Tridash code. The
special `:extern` declaration creates a meta-node without a definition.

.Syntax
--------------------------------------------------
:extern(id)
--------------------------------------------------

`id` is the identifier of the meta-node to create.

An external definition for the meta-node has to be provided, and
linked with the generated code. In the JavaScript backend, instances
of the meta-node are compiled to a call to the JavaScript function
with the same name as the node identifier. If the `public-name`
attribute of the meta-node is set, a call to the JavaScript function
with the value of the attribute is generated instead.

=== Instances as Targets ===

By default, a meta-node instance appearing as the target of a binding,
that is on the right hand side of the `->` operator, will result in a
compilation error. You may have noticed, however, that some meta-nodes
in the <<_core_module, `core`>> module, can also appear as the targets
of the binding, particularly <<meta-node-int, `int`>>,
<<meta-node-real, `real`>> and <<meta-node-not, `not`>>. This is
achieved by setting the `target-node` attribute.

The `target-node` attribute stores the identifier of the meta-node,
which is applied on the value of the meta-node instance, in order to
compute the value of the arguments. When the `target-node` attribute
is set, a binding is established between the meta-node instance, as
the dependency, and each argument node, as the observer. The function
of the binding context is set to the meta-node with the identifier
stored in the `target-node` attribute.

NOTE: Currently the `target-node` attribute is only useful for single
argument nodes as no information about the position of the argument is
passed to the meta-node.

As an example consider a meta-node `f` with the `target-node`
attribute set to `g`. A declaration of the form:

--------------------------------------------------
x -> f(arg)
--------------------------------------------------

results in the following binding being established:

--------------------------------------------------
g(f(arg)) -> arg
--------------------------------------------------

This is useful for creating _invertable_ meta-nodes where instead of
computing a result given the values of the argument nodes, the values
of the argument nodes can be computed given the result. This is
achieved by binding to the meta-node instance, with the `target-node`
attribute set to the _inverse_ function.

The <<meta-node-not, `not`>> meta-node from the `core` module has its
`target-node` attribute set to `not`. Thus the binding `x -> not(y)`,
will result in the value of `y` being set to the value `not(x)`, on
changes in the value of `x`.

CAUTION: In order for the bindings to the argument nodes, to be
established, the `:attribute` declaration which sets the `target-node`
attribute must occur before the first instance of the
meta-node, however after the meta-node is defined.

[TIP]
==================================================
Attributes are set on meta-nodes in the same way as they are set for
ordinary nodes. To set the `target-node` attribute of a meta-node `f`
to `g`, use the following declaration:

--------------------------------------------------
:attribute(f, target-node, g)
--------------------------------------------------
==================================================


== Modules ==
