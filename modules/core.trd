### Tridash Core Module
###
### Contains meta-node stubs, and operator table, for the language
### primitives.

:module(core)
:import(builtin)

### Operators

## Basic Operators

:op(->, 10, right)
:op(:, 5, right)

:op(., 1000, left)

:export(->, :, .., ., &)


## Arithmetic Operators

:op(+, 100, left)
:op(-, 100, left)

:op(*, 200, left)
:op(/, 200, left)


## Comparison Operators

:op(<, 50)
:op(<=, 50)
:op(>, 50)
:op(>=, 50)
:op(=, 50)
:op(!=, 50)


## Logical Operators

:op(and, 25)
:op(or, 20)


## Error handling

:op(?->, 10, right)
:export(?->)


### Metanode stubs for primitive operators

## Arithmetic and logical operators

:extern(+, a, b)
:attribute(+, strictness, or(a,b))

:extern(-, a, :(b))
:attribute(-, strictness, or(a,b))

:extern(*, a, b)
:attribute(*, strictness, or(a,b))

:extern(/, a, b)
:attribute(/, strictness, or(a,b))

:extern(<, a, b)
:attribute(<, strictness, or(a,b))

:extern(<=, a, b)
:attribute(<=, strictness, or(a,b))

:extern(>, a, b)
:attribute(>, strictness, or(a,b))

:extern(>=, a, b)
:attribute(>=, strictness, or(a,b))

:extern(=, a, b)
:attribute(=, strictness, or(a,b))

:extern(!=, a, b)
:attribute(!=, strictness, or(a,b))

:extern(and, a, b)
:attribute(and, strictness, a)

:extern(or, a, b)
:attribute(or, strictness, a)

:extern(not, x)
:attribute(not, strictness, x)
:attribute(not, target-node, not)

:export(+, -, *, /, <, <=, >, >=, =, !=, and, or, not)


## Conditions

:export(if, case)


## Type Conversions

:extern(int, x)
:attribute(int, strictness, x)
:attribute(int, target-node, int)

:extern(real, x)
:attribute(real, target-node, real)
:attribute(real, strictness, x)

:extern(string, x)
:attribute(string, strictness, x)
:attribute(string, target-node, string)

:export(int, real, string)


## Type Checks

:extern(int?, x)
:attribute(int?, strictness, x)

:extern(real?, x)
:attribute(real?, strictness, x)

:extern(string?, x)
:attribute(string?, strictness, x)

:extern(inf?, x)
:attribute(inf?, strictness, x)

:extern(NaN?, x)
:attribute(NaN?, strictness, x)

:export(int?, real?, string?, inf?, NaN?)


## Lists

:extern(cons, head, tail)
:extern(list, ..(xs))

:extern(head, list)
:attribute(head, strictness, list)

:extern(tail, list)
:attribute(tail, strictness, tail)


nth(list, n) :
    if (n = 0, head(list), nth(tail(list), n - 1))

:export(cons, list, head, tail)


### Standard Library

## Number Parsing

# Attempts to parse an integer from `x`
#
# x: Value from which the integer is parsed.
#
# Evaluates to an object with two subnodes:
#
# value: The parsed integer value, or NaN if parsing failed.
# fail: True on failure, false on success.

parse-int(x) : {
   int(x) -> i

   i -> self.value
   NaN?(i) -> self.fail
}

# Attempts to parse a real value from `x`
#
# x: Value from which the real is parsed.
#
# Evaluates to an object with two subnodes:
#
# value: The parsed real value, or NaN if parsing failed.
# fail: True on failure, false on success.

parse-real(x) : {
   real(x) -> r

   r -> self.value
   NaN?(r) -> self.fail
}

:export(parse-int, parse-real)


## Logical Operators

# Evaluates to `value` if `cond` is true, otherwise evaluates to a
# null value.
#
# cond: The condition.
# value: The value to evaluate to if `cond` is true.

|-(cond, value) : case(cond : value)

:op(|-, 25, right)

:export(|-)