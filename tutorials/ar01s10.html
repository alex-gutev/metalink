<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10. Node States</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Tridash Tutorials" /><link rel="up" href="index.html" title="Tridash Tutorials" /><link rel="prev" href="ar01s09.html" title="9. Contexts" /><link rel="next" href="ar01s11.html" title="11. List Processing" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ar01s09.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s11.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_node_states"></a>10. Node States</h2></div></div></div><p>So far, we’ve seen that Tridash is good at producing an output, which
is a function of a given input, and ensuring that it is always
synchronized with the input. What we haven’t seen, however, is mapping
a previous output to a new output. In-fact, with the tools introduced
so far, this is impossible.</p><p>To be able to map a previous output to a new output, a binding has to
be established in which the <span class="emphasis"><em>source</em></span> is a function of the <span class="emphasis"><em>target</em></span>
node. As an example, to implement a counter, intuitively we might do
the following:</p><pre class="screen"># This does not work!!!
counter + 1 -&gt; counter</pre><p>The problem here is that a change in the value of <code class="literal">counter</code> triggers a
change in the value of <code class="literal">counter</code>, which triggers a further change in
the value of <code class="literal">counter</code> <span class="emphasis"><em>ad infinitum</em></span>. What we require is a way to
tell Tridash, that when the value of <code class="literal">counter</code> is updated to <code class="literal">counter
+ 1</code>, it should not trigger another update to the value of <code class="literal">counter +
1</code>. We also need a way to specify when we would like the value of
<code class="literal">counter</code> to be updated to <code class="literal">counter + 1</code>, as updating it only once is
hardly useful.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_stateful_bindings"></a>10.1. Stateful Bindings</h3></div></div></div><p>Node states allow us to control when the value of a node is updated,
beyond the simple rule of <span class="emphasis"><em>whenever the value of one of its dependency
nodes changes</em></span>. The target of a binding can have an explicit <span class="emphasis"><em>state</em></span>
associated with it, using the <code class="literal">::</code> operator. In this case the binding
is referred to as a <span class="emphasis"><em>stateful binding</em></span>.</p><p><strong>Explicit state using <code class="literal">::</code> operator. </strong>
</p><pre class="screen">a -&gt; b :: state-id</pre><p>
</p><p>The left-hand side of the <code class="literal">::</code> operator is the node and the right hand
side is the state identifier, which is a symbol identifier (similar to
a context identifier). The result of this is that the binding <code class="literal">a -&gt; b</code>
only takes effect when <code class="literal">b</code> <span class="strong"><strong><span class="emphasis"><em>switches</em></span></strong></span> to the state with identifier
<code class="literal">state-id</code>. The emphasis is on <span class="emphasis"><em>switches</em></span> as a change in the value of
<code class="literal">a</code> will not automatically trigger a change in the value of <code class="literal">b</code>. Only
a change in the <span class="emphasis"><em>state</em></span> of <code class="literal">b</code> will trigger a change in its
value. This may seem counter-intuitive at first, however if <code class="literal">b</code> was
updated on every change in the value of <code class="literal">a</code>, and instead of <code class="literal">a</code> we
have <code class="literal">b + 1</code> we’ll end up with the same problem in the previous
section.</p><div class="important" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Stateful bindings declared later in the source take
priority over those declared earlier.</p></td></tr></table></div><p>A node’s state is determined by the value of the special node
<code class="literal">/state(node)</code>. Binding to it allows us to control a node’s state.</p><p><strong>Example: Counter. </strong>
</p><pre class="screen">counter + 1 -&gt; counter :: increment

/state(counter) &lt;-
    case(
        should-increment? : '(increment),
        '(default)
    )</pre><p>
</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The <code class="literal">'</code> operator returns its argument as a literal symbol.
<code class="literal">'(id)</code> returns the literal symbol <code class="literal">id</code>, whereas <code class="literal">id</code> on its own is a
reference to the value of the node with identifier
<code class="literal">id</code>. <a href="#ftn.idm480107550656" class="footnote" id="idm480107550656"><sup class="footnote">[1]</sup></a></p></td></tr></table></div><p>In this example, a binding <code class="literal">counter + 1 -&gt; counter</code> is established
which only takes effect when <code class="literal">counter</code> switches to the <code class="literal">increment</code>
state.</p><p>The second declaration binds a <code class="literal">case</code> expression to the
<code class="literal">/state(counter)</code> node, thus controlling the state of <code class="literal">counter</code>. When
<code class="literal">should-increment?</code> is true the value of the <code class="literal">case</code> expression, and
thus the state of <code class="literal">counter</code> is <code class="literal">increment</code>, otherwise it is <code class="literal">default</code>.</p><p>The result is that when the value of <code class="literal">/state(counter)</code> (the state of
<code class="literal">counter</code>) is updated to <code class="literal">increment</code>, the value of <code class="literal">counter</code> is
updated to it’s previous value incremented by 1.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_interfacing_with_javascript"></a>10.2. Interfacing with JavaScript</h3></div></div></div><p>To provide a runnable example, we have to interface with JavaScript in
order to hook into its event system. In the next major release of
Tridash, this wont be necessary.</p><p>This section will go over only the basics of interfacing with
JavaScript, which are necessary for completing this tutorial. A full
in-depth tutorial on interfacing with JavaScript, will follow.</p><p>Tridash nodes are compiled to runtime node objects, which store the
node’s value and information about its dependencies, observers,
contexts, etc. To be able to reference a runtime node object, from
JavaScript, the node has to be given an identifier with which it can
be referenced. The <code class="literal">public-name</code> attribute, if given, determines the
name of this identifier.</p><p>Once an identifier is given, it can be accessed as a member of the
<code class="literal">Tridash.nodes</code> object. <code class="literal">Tridash</code> is the object/module storing the
Tridash runtime library functions. The <code class="literal">nodes</code> member of Tridash is an
object storing references to all nodes which have been given a
<code class="literal">public-name</code> identifier.</p><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Currently Tridash does not check whether multiple nodes are
given the same <code class="literal">public-name</code>.</p></td></tr></table></div><p><strong>Example: Setting <code class="literal">public-name</code> identifier. </strong>
</p><pre class="screen">/attribute(node, public-name, "aNode")</pre><p>
</p><p><strong>Example: Referencing the runtime node object in JavaScript. </strong>
</p><pre class="screen">var node = Tridash.nodes["aNode"];

// or equivalently if the public-name is a valid JS variable name
var node = Tridash.nodes.aNode;</pre><p>
</p><p>Once a reference is obtained to the runtime node object, the node’s
value can be set using the <code class="literal">set_value</code> method, which takes the value
as an argument.</p><p><strong>Example: Setting Node Value from JavaScript. </strong>
</p><pre class="screen">node.set_value(1);</pre><p>
</p><p>It is important, however, that if <code class="literal">set_value</code> will be called on a
runtime node object, the node is marked as an <span class="emphasis"><em>input</em></span> node, by setting
its <code class="literal">input</code> attribute to true.</p><pre class="screen">/attribute(node, input, 1)</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Currently an attribute is set to <code class="literal">true</code> when it is given the
value <code class="literal">1</code> and set to <code class="literal">false</code> when it is given the value <code class="literal">0</code>. In the
next release, you’ll be able to use the symbols <span class="emphasis"><em>True</em></span> and <span class="emphasis"><em>False</em></span>
instead.</p></td></tr></table></div><div class="caution" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/icons/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Not every Tridash node corresponds to an actual runtime node
object, due to some intermediate nodes being optimized out by the
compiler. The only nodes, for which it is guaranteed that a runtime
node object is created, are <span class="emphasis"><em>input</em></span> nodes and nodes with no observers,
which are assumed to represent <span class="emphasis"><em>output</em></span> nodes.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_example_counter_application"></a>10.3. Example: Counter Application</h3></div></div></div><p>In this section we’ll build a very simple application consisting of a
counter which is incremented when a button is pressed.</p><p>Let’s start off with the Tridash binding declarations. We’ve in-fact
already written the bulk of the code in the previous example, which we
can simply copy into our new application.</p><pre class="screen">counter + 1 -&gt; counter :: increment

/state(counter) &lt;-
    case(
        should-increment? : '(increment),
        '(default)
    )</pre><p>The node <code class="literal">counter</code> stores the value of the counter which is
incremented when <code class="literal">should-increment?</code> is true. We’ll add the attributes
which are necessary in order to be able to set the value of
<code class="literal">should-increment?</code> from JavaScript, namely we need to set a
<code class="literal">public-name</code> identifier and mark it as an <code class="literal">input</code> node.</p><pre class="screen">/attribute(should-increment?, input, 1)
/attribute(should-increment?, public-name, "should_increment")</pre><p>We’ll allow the user to set/reset the value of the counter by binding
a <code class="literal">start</code> node to an input field. We’ll bind <code class="literal">start</code> directly to
<code class="literal">counter</code> and give it an initial value of <code class="literal">0</code>.</p><pre class="screen">start -&gt; counter
0 -&gt; start</pre><p>Now let’s define the user interface. We need a text input field for
entering the initial value for the counter, which will be bound to
<code class="literal">start</code> and an <span class="emphasis"><em>increment</em></span> button. The value of the counter will be
displayed below the counter.</p><p><strong><code class="literal">ui.html</code>. </strong>
</p><pre class="screen">...
&lt;div&gt;&lt;label&gt;Start: &lt;input value="&lt;?@ to-int(start) ?&gt;"/&gt;&lt;/label&gt;&lt;/div&gt;
&lt;div&gt;&lt;button id="increment"&gt;Increment&lt;/button&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;div&gt;&lt;strong&gt;Counter: &lt;?@ counter ?&gt;&lt;/strong&gt;&lt;/div&gt;
...</pre><p>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The HTML boilerplate is not shown.</p></td></tr></table></div><p>We’ve given the <span class="emphasis"><em>Increment</em></span> button the ID <code class="literal">increment</code> so that we can
attach an event listener to its <span class="emphasis"><em>click</em></span> event. We’ll do so using the
following JavaScript code, in a script tag which should be added below
the element where the counter is displayed:</p><pre class="screen">&lt;script&gt;
  var increment = document.getElementById('increment');
  var node_increment = Tridash.nodes.should_increment;

  increment.addEventListener('click', function() {
      node_increment.set_value(true);
      node_increment.set_value(false);
  });
&lt;/script&gt;</pre><p>The first line obtains a reference to the HTML element with ID
<code class="literal">increment</code>.</p><p>The second line obtains a reference to the <code class="literal">should-increment?</code> node
which was given a <code class="literal">public-name</code> of <code class="literal">should_increment</code>.</p><p>The remainder of the code attaches a listener, for the <span class="emphasis"><em>click</em></span> event,
on the <span class="emphasis"><em>Increment</em></span> button. In that listener we first set the value of
the <code class="literal">should-increment?</code> node to true, then immediately afterwards we
set it to false again.</p><p>Setting the value of <code class="literal">should-increment?</code> to true, causes the state of
<code class="literal">counter</code> to change to <code class="literal">increment</code>. Setting it back to false again
causes the state to change to <code class="literal">default</code>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>In a future release, when the HTML library is complete, a
subnode <code class="literal">clicked?</code>, of the element node, will be available which will
automatically be set to true when the button is clicked and to false
when it is released. Thus the above JavaScript code wont be necessary.</p></td></tr></table></div><p>Build and run the application, and press the increment button a few
times:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap1.png" align="middle" alt="Start: 0, Counter: 1" /></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap2.png" align="middle" alt="Start: 0, Counter: 2" /></div></div><p>The displayed value, for the counter, is incremented after each press.</p><p>Now enter a value in the <span class="emphasis"><em>Start</em></span> field to reset the counter, and then
press the increment button again:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap3.png" align="middle" alt="Start: 5, Counter: 5" /></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap4.png" align="middle" alt="Start: 5, Counter: 6" /></div></div><p>The counter is reset to the value entered in the <span class="emphasis"><em>Start</em></span>
field. Pressing increment afterwards increments the new counter value.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_state_transitions"></a>10.4. State Transitions</h3></div></div></div><p>Let’s do a little experiment, comment out the line, in the <span class="emphasis"><em>click</em></span>
event handler, which sets the value of the <span class="emphasis"><em>should-increment?</em></span> node to
<span class="emphasis"><em>false</em></span>, i.e. comment out the following:</p><pre class="screen">node_increment.set_value(false);</pre><p>What do you expect to happen? Initially, we might think that since the
<code class="literal">should-increment?</code> node is not being reset to false, the state of
<code class="literal">counter</code> is not being reset to <code class="literal">default</code>. The state of <code class="literal">counter</code> will
thus switch to <code class="literal">increment</code> once, after which, there are no further
state changes. The result is that the counter will only be incremented
the first time the increment button is pressed.</p><p>Let’s try it. Build and run the application and press the increment
button twice.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap5.png" align="middle" alt="Start: 0, Counter: 2" /></div></div><p>What happened? The counter carries on incrementing after the first
button press. Why?</p><p>The declaration:</p><pre class="screen">counter + 1 -&gt; counter :: increment</pre><p>states that the binding should only take effect when the state of
<code class="literal">counter</code> switches to the <code class="literal">increment</code> state. Switching from the
<code class="literal">increment</code> state to the <code class="literal">increment</code> is still considered as switching
to the <code class="literal">increment</code> state, even though the new state is identical to
the previous state. This is due to the fact that each time we’re
setting the value of the <code class="literal">should-increment?</code> node to <code class="literal">true</code>, we’re
triggering a change in the value of the node <code class="literal">/state(counter)</code> and
thus the state of <code class="literal">counter</code>, even though the new value of
<code class="literal">should-increment?</code> is identical to its previous value.</p><p>The above declaration should thus be thought of as declaring a binding
which takes effect whenever <code class="literal">counter</code> switches from any state,
including <code class="literal">increment</code>, to the <code class="literal">increment</code> state.</p><p>To fix this issue we can specify an explicit <span class="emphasis"><em>from</em></span> state. When
specified, the binding only takes effect when the state of the node
changes from the <span class="emphasis"><em>from</em></span> state to the <span class="emphasis"><em>to</em></span> state. This is specified
using the following syntax:</p><p><strong>Node State Binding with Explicit From State. </strong>
</p><pre class="screen">a -&gt; b :: previous =&gt; next</pre><p>
</p><p>When the state identifier is a functor of the form <code class="literal">previous =&gt; next</code>,
<code class="literal">previous</code> is interpreted as the identifier of the <span class="emphasis"><em>from</em></span> state and
<span class="emphasis"><em>next</em></span> is interpreted as the identifier of the <span class="emphasis"><em>to</em></span> state.</p><p>To achieve the intuitive behaviour we can limit the binding <code class="literal">counter +
1 -&gt; counter</code> to only take effect when the state of counter
transitions from <code class="literal">default</code> to <code class="literal">increment</code>. Replace the binding
declaration of <code class="literal">counter</code> with the following:</p><pre class="screen">counter + 1 -&gt; counter :: default =&gt; increment</pre><p>This implementation will, however, require two initial button presses
before the counter starts incrementing. This is due to the fact that
we haven’t given <code class="literal">counter</code> an initial state. The first press causes it
to change to <code class="literal">increment</code>, and then back to default, however since it
is not a change from <code class="literal">default</code> to <code class="literal">increment</code>, the binding does not
take effect. We can fix this by giving <code class="literal">/state(counter)</code> an initial
value of <code class="literal">default</code>.</p><p><strong>Setting Initial State. </strong>
</p><pre class="screen">'(default) -&gt; /state(counter)</pre><p>
</p><p>Now the counter starts incrementing after the first press.</p><p>Let’s repeat the experiment on this new implementation, comment out
the line, in the JavaScript script tag, which sets the value of
<code class="literal">should-increment?</code> to <code class="literal">false</code>. The counter should only increment the
first time the <span class="emphasis"><em>Increment</em></span> button is pressed.</p><p>This example served to demonstrate the difference between a stateful
binding with and without a <span class="emphasis"><em>from</em></span> state. However, in this example,
there is no value in specifying a from state, as the previous example,
without a from state, was simpler and performed the same function.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_example_alternating_increment_button"></a>10.5. Example: Alternating Increment Button</h3></div></div></div><p>In this example, we’ll build a silly application in which the
<span class="emphasis"><em>Increment</em></span> button, the button which actually increments the counter,
alternates between two buttons. The goal of this example is to
demonstrate what can be done with stateful bindings with a <span class="emphasis"><em>from</em></span>
state that cannot be done with stateful bindings without a <span class="emphasis"><em>from</em></span>
state.</p><p>We’ll start off with a similar interface to the previous counter
application, however with two increment buttons.</p><p><strong><code class="literal">ui.html</code>. </strong>
</p><pre class="programlisting">&lt;h1&gt;Counter&lt;/h1&gt;
&lt;div&gt;&lt;label&gt;Start: &lt;input value="&lt;?@ to-int(start) ?&gt;"/&gt;&lt;/label&gt;&lt;/div&gt;
&lt;div&gt;
  &lt;button id="increment1"&gt;Increment 1&lt;/button&gt;
  &lt;button id="increment2"&gt;Increment 2&lt;/button&gt;
&lt;/div&gt;
&lt;hr/&gt;
&lt;div&gt;&lt;strong&gt;Counter: &lt;?@ counter ?&gt;&lt;/strong&gt;&lt;/div&gt;</pre><p>
</p><p>Both button’s have been given ID’s as we’ll need to attach event
listeners to both buttons, in JavaScript.</p><p>We’ll need two nodes <code class="literal">clicked1?</code> and <code class="literal">clicked2?</code> which change to true
when the first and second buttons are clicked, respectively. The
values of these nodes will have to be set via JavaScript, thus we’ll
have to mark them as input nodes and set their <code class="literal">public-name</code>
attributes:</p><pre class="screen">/attribute(clicked1?, input, 1)
/attribute(clicked1?, public-name, "clicked1");

/attribute(clicked2?, input, 1)
/attribute(clicked2?, public-name, "clicked2");</pre><p>The following JavaScript code attaches event listeners for the
<span class="emphasis"><em>clicked</em></span> events, of both buttons, which simply set the value of the
corresponding <span class="emphasis"><em>clicked?</em></span> node to true and them immediately to false,
again.</p><pre class="screen">var increment1 = document.getElementById('increment1');
var increment2 = document.getElementById('increment2');

var clicked1 = Tridash.nodes.clicked1;
var clicked2 = Tridash.nodes.clicked2;

increment1.addEventListener('click', function() {
    clicked1.set_value(true);
    clicked1.set_value(false);
});

increment2.addEventListener('click', function() {
    clicked2.set_value(true);
    clicked2.set_value(false);
});</pre><p>We’ll need two states for the <code class="literal">counter</code> node:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<code class="literal">increment1</code>
</span></dt><dd>
Corresponds to the first button being clicked last.
</dd><dt><span class="term">
<code class="literal">increment2</code>
</span></dt><dd>
Corresponds to the second button being clicked last.
</dd></dl></div><p>The value of <code class="literal">counter</code> should be incremented only when its state
switches from one state to the other, i.e. the button, which was
clicked, is different from the previous button to be clicked. This can
be achieved using two stateful bindings which take effect during the
state transitions <code class="literal">increment1 =&gt; increment2</code>, <code class="literal">increment2 =&gt;
increment1</code>.</p><pre class="screen">counter + 1 -&gt; counter :: increment1 =&gt; increment2
counter + 1 -&gt; counter :: increment2 =&gt; increment1</pre><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="literal">counter + 1</code> can be refactored into a separate node to avoid
having to type it out twice.</p></td></tr></table></div><p><code class="literal">counter</code> will retain its previous value during any other state
transition.</p><p>We need to set <code class="literal">counter</code>'s state, to <code class="literal">increment1</code> or
<code class="literal">increment2</code>, based on which button was clicked last. To achieve that
we can exploit the fact that each explicit binding to a node, without
an explicit context, results in the creation of a new context. When
the value of the <span class="emphasis"><em>source</em></span> node, of the binding, changes, the binding
context is activated.</p><p>We know that the value of <code class="literal">clicked1</code> changes to true, and then to
false, again, when the first button is clicked. The same is true for
<code class="literal">clicked2</code> when the second button is pressed. We want the state of
<code class="literal">counter</code> (<code class="literal">/state(counter)</code>) to be bound to the literal symbol
<code class="literal">increment1</code>, when the value of <code class="literal">clicked1</code> changes regardless of what
that value is. For that, we can use the utility <code class="literal">!-</code> meta-node,
introduced in <a class="xref" href="ar01s09.html#adding-numbers-improved-error-handling" title="9.3. Improved Error Handling in Adding Numbers">Section 9.3, “Improved Error Handling in <span class="emphasis"><em>Adding Numbers</em></span>”</a>, which
returns the value of its second argument if its first argument does
not evaluate to a failure.</p><p>The following are the binding declarations which set the state of
<code class="literal">counter</code>.</p><pre class="screen">clicked1? !- '(increment1) -&gt; /state(counter)
clicked2? !- '(increment2) -&gt; /state(counter)</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The sole purpose of the <code class="literal">!-</code> operator is to force the value of
<code class="literal">/state(counter)</code> to be updated whenever the value <code class="literal">clicked1</code> or
<code class="literal">clicked2</code> changes.</p></td></tr></table></div><p>To make it obvious which button should be clicked, we’ll make the
button which increments the counter change to green. We’ll bind each
button’s background color to <code class="literal">"green"</code> if the other button was the
last button to be pressed, and <code class="literal">"gray"</code> if it was the last button to
be pressed. This is achieved with the following:</p><pre class="screen">increment1 &lt;- /state(counter) = '(increment1)
increment2 &lt;- /state(counter) = '(increment2)

case (increment2 : "green", "gray") -&gt;
    self.increment1.style.backgroundColor
case (increment1 : "green", "gray") -&gt;
    self.increment2.style.backgroundColor</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>We’re comparing the state of counter directly to determine which
button was pressed last.</p></td></tr></table></div><p>Finally, let’s make the initial state of <code class="literal">counter</code>, <code class="literal">increment2</code> so
that pushing on the first button, increments the counter.</p><p>Build and run the application. Initially you should see something
similar to the following:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap6.png" align="middle" alt="Start: 0, Increment 1 (green), Increment 2, Counter: 0" /></div></div><p>Click on the green <span class="emphasis"><em>Increment 1</em></span> button:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap7.png" align="middle" alt="Start: 0, Increment 1, Increment 2 (green), Counter: 1" /></div></div><p>The counter is incremented by one, and the button changes to grey with
the other button changing to green. Clicking on the same, now grey,
button will not affect the value of the counter.</p><p>Click on the green <span class="emphasis"><em>Increment 2</em></span> button:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap8.png" align="middle" alt="Start: 0, Increment 1 (green), Increment 2, Counter: 2" /></div></div><p>The counter is incremented once again, and button <span class="emphasis"><em>Increment 1</em></span>
changes back to green with button <span class="emphasis"><em>Increment 2</em></span> changing back to
<span class="emphasis"><em>grey</em></span>.</p><p>Just to make sure everything works properly let’s reset the counter
and push the green button to increment it.</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap9.png" align="middle" alt="Start: 10, Increment 1 (green), Increment 2, Counter: 10" /></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial10/snap10.png" align="middle" alt="Start: 10, Increment 1, Increment 2 (green), Counter: 11" /></div></div><p>Everything works as expected. The state of <code class="literal">counter</code> does not affect
the binding <code class="literal">start -&gt; counter</code> as it is a <span class="emphasis"><em>stateless</em></span>, without an
explicit state specified, binding.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_exercises"></a>10.6. Exercises</h3></div></div></div><p>Try out the following as an exercise:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Change the previous application such that clicking on the grey
  button, i.e. the button which does not increment the counter,
  decrements the counter.
</li><li class="listitem">
Implement a toggle button of which the background color, and text,
  changes when pressed.
</li></ul></div></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm480107550656" class="footnote"><p><a href="#idm480107550656" class="simpara"><sup class="simpara">[1] </sup></a>This performs a similar function to Lisp’s <code class="literal">quote</code> or
<code class="literal">'</code> operator</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s09.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s11.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>