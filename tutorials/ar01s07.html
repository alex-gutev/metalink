<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>7. Failure Types</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Tridash Tutorials" /><link rel="up" href="index.html" title="Tridash Tutorials" /><link rel="prev" href="ar01s06.html" title="6. Error Handling with Failure Values" /><link rel="next" href="ar01s08.html" title="8. Target Node Transforms" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ar01s06.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s08.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_failure_types"></a>7. Failure Types</h2></div></div></div><p>The error handling tools we’ve seen so far have one serious
shortcoming, there is no means for identifying the cause of the
error. In the application, which we augmented with error handling in
the previous tutorial, we don’t check at all what the cause of the
failure is. Instead, we simply assumed that a failure value means
invalid input was entered. Whilst this is the case in our simple
application, it is not the case for more complex real world
applications where there are many potential sources of errors.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_identifying_the_cause_of_failures"></a>7.1. Identifying the cause of Failures</h3></div></div></div><p>Each failure value has an associated type, which is a value that
identifies the cause of the failure. The <span class="emphasis"><em>failure type</em></span> can be
obtained using the <code class="literal">fail-type</code> meta-node from the <code class="literal">core</code> module. If
the argument of <code class="literal">fail-type</code> evaluates to a failure, the meta-node
returns its type, otherwise if the argument does not evaluate to a
failure or evaluates to a failure without a type, the meta-node
returns a failure.</p><p>The meta-node <code class="literal">fail-type</code> is a bit clunky to use as it, itself,
returns a failure if the argument does not evaluate to a failure
value. The utility <code class="literal">fail-type?</code> meta-node, also from the <code class="literal">core</code>
module, takes two arguments, a value and a failure type, and returns
true if the value evaluates to a failure of that type.</p><p>A value used as a failure type is generally bound to a constant node,
which is used in place of the raw value. An accompanying node, with
the same identifier but with a trailing <code class="literal">!</code> is bound to a failure of
the type.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_example_checking_failure_type_in_emphasis_adding_numbers_emphasis_application"></a>7.2. Example: Checking Failure type in <span class="emphasis"><em>Adding Numbers</em></span> Application</h3></div></div></div><p>The type of the failure returned by <code class="literal">to-int</code>, when given a string that
does not contain a valid integer, is designated by the node
<code class="literal">Invalid-Integer</code>, from the <code class="literal">core</code> module. The node <code class="literal">Invalid-Integer!</code>
is bound to a failure of type <code class="literal">Invalid-Integer</code>.</p><p>We can use the <code class="literal">fail-type?</code> meta-node to explicitly check whether the
failure is of the type <code class="literal">Invalid-Integer</code>. Simply replace
<code class="literal">fails?(value)</code> with <code class="literal">fail-type?(value, Invalid-Integer)</code> in the
definition of the <code class="literal">error-message</code> meta-node.</p><p><strong>Improved <code class="literal">error-message</code> Meta-Node. </strong>
</p><pre class="screen">error-message(value) :
    case(
        fail-type?(value, Invalid-Integer) : "Not a valid number!",
        ""
    )</pre><p>
</p><p>The new implementation returns the string “Not a valid number!” only
for errors caused by invalid input being entered. It returns the empty
string for errors of any other type.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_creating_failure_values"></a>7.3. Creating Failure Values</h3></div></div></div><p>Failures are limited in use if they can only be created by builtin
meta-nodes. You can create your own failure values using the <code class="literal">fail</code>
meta-node, which takes one optional argument — the type of the
failure. If the type argument is not provided, a failure without a
type is created.</p><p><strong>Example. </strong>
</p><pre class="screen"># Creates failure with no type
fail()

# Creates a failure with type `My-Type`
fail(My-Type)</pre><p>
</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_example_positive_numbers_only"></a>Example: Positive Numbers Only</h4></div></div></div><p>Suppose for some reason, we’d like to limit the numbers being added,
in the <span class="emphasis"><em>Adding Numbers</em></span> application, to positive numbers. It could
be that the numbers represent amounts for which negative values do not
make sense in the context of the application.</p><p>Let’s write a meta-node, <code class="literal">validate</code>, which takes an integer value and
returns that value if it is greater than or equal to zero. Otherwise
it returns a failure of a user-defined type designated by the node
<code class="literal">Negative-Number</code>.</p><p><strong>Meta-Node <code class="literal">validate</code>. </strong>
</p><pre class="screen">validate(x) :
    case(
        x &gt;= 0 : x,
        fail(Negative-Number)
    )</pre><p>
</p><p>If the argument <code class="literal">x</code> is greater than or equal to zero it is returned
directly, otherwise a failure, created using the <code class="literal">fail</code> meta-node, of
type designated by <code class="literal">Negative-Number</code> is returned.</p><p>Now let’s bind the <code class="literal">Negative-Number</code> node to a value, which uniquely
identifies the failure. For now let’s choose the value <code class="literal">-1</code>. While
we’re at it let’s also define the <code class="literal">Negative-Number!</code> meta-node which
is simply bound to a failure of type <code class="literal">Negative-Number</code>.</p><p><strong>Failure Type `Negative-Number `. </strong>
</p><pre class="screen">Negative-Number  &lt;- -1
Negative-Number! &lt;- fail(Negative-Number)</pre><p>
</p><p>We can simplify <code class="literal">validate</code> by substituting <code class="literal">fail(Negative-Number)</code>
with <code class="literal">Negative-Number!</code>:</p><p><strong>Simplified <code class="literal">validate</code> Meta-Node. </strong>
</p><pre class="screen">validate(x) :
    case(
        x &gt;= 0 : x,
        Negative-Number!
    )</pre><p>
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>It does not matter whether you place the binding declarations of
the nodes <code class="literal">Negative-Number</code> and <code class="literal">Negative-Number!</code> before or after the
definition of <code class="literal">validate</code>.</p></td></tr></table></div><p>To incorporate this in our application, we have to change the nodes,
to which the input fields are bound, from <code class="literal">a</code> and <code class="literal">b</code> to <code class="literal">input-a</code> and
<code class="literal">input-b</code>.</p><p>Replace <code class="literal">a</code> with <code class="literal">input-a</code>, in the text field for <span class="emphasis"><em>A</em></span>, and <code class="literal">b</code> with
<code class="literal">input-b</code> in the text field for <span class="emphasis"><em>B</em></span>.</p><pre class="screen">...
&lt;label&gt;A: &lt;input value="&lt;?@ to-int(input-a) ?&gt;"/&gt;&lt;/label&gt;
...
&lt;label&gt;B: &lt;input value="&lt;?@ to-int(input-b) ?&gt;"/&gt;&lt;/label&gt;
...</pre><p>Also change the setting of initial values such that they are set on
nodes <code class="literal">input-a</code> and <code class="literal">input-b</code> rather than <code class="literal">a</code> and <code class="literal">b</code>.</p><pre class="screen">0 -&gt; input-a
0 -&gt; input-b</pre><p>Now we’re going to bind <code class="literal">a</code> to the result of <code class="literal">validate</code> applied on
<code class="literal">input-a</code> and we’re going to bind <code class="literal">b</code> to the result of <code class="literal">validate</code>
applied on <code class="literal">input-b</code>.</p><pre class="screen">a &lt;- validate(input-a)
b &lt;- validate(input-b)</pre><p>Finally let’s update the <code class="literal">error-message</code> meta-node to return “Number
must be greater than or equal to 0!” in the case that the failure
is of type <code class="literal">Negative-Number</code>.</p><p><strong>Updated <code class="literal">error-message</code> Meta-Node. </strong>
</p><pre class="screen">error-message(value) :
    case(
        fail-type?(value, Invalid-Integer) :
            "Not a valid number!",
        fail-type?(value, Negative-Number) :
            "Number must be greater than or equal to 0!",
        ""
    )</pre><p>
</p><p>Build and run the application and enter a positive number in one field
and a negative number in the other:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial7/snap1.png" align="middle" alt="A: 1, B: -1, Number must be greater than or equal to 0!, A + B = 1" /></div></div><p>The error message, explaining that a positive number (or zero) must be
entered, is displayed next to the field where the negative number was
entered, <span class="emphasis"><em>B</em></span> in this case. The result of the addition with the new
numbers entered is not displayed, instead the previous result is
retained, as expected.</p><p>Change the negative number to an invalid number:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial7/snap2.png" align="middle" alt="A: 1, B: foo, Not a valid number!, A + B = 1" /></div></div><p>The error message changes to “Not a valid number!” and the displayed
sum is unchanged, as in the previous versions.</p><p>Now change the value to a valid positive number:</p><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/tutorial7/snap3.png" align="middle" alt="A: 1, B: 2, A + B = 3" /></div></div><p>The error message disappears and the new sum is displayed.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_proper_failure_types"></a>7.4. Proper Failure Types</h3></div></div></div><p>There is one issue with the application we’ve just developed. There is
no guarantee that the arbitrary constant <code class="literal">-1</code> uniquely represents a
failure of type <code class="literal">Negative-Number</code>. If all failure types used arbitrary
integer constants, there is no guarantee that <code class="literal">-1</code> doesn’t already
represent a builtin failure type, such as <code class="literal">Invalid-Integer</code>. Whilst it
so happened to work, it is certainly not robust, especially when
bringing in third party libraries.</p><p>A value, which is guaranteed to be unique, can be obtained by taking a
reference to the <span class="emphasis"><em>raw node object</em></span> of <code class="literal">Negative-Number</code>.</p><p>References to the raw node object, of a node, can be obtained using
the <code class="literal">&amp;</code> special operator, which takes the identifier of the node as an
argument. Raw node references are mostly useful when writing macros,
which you’ll learn about in a later tutorial. For now all that you
need to know is that this value can serve as the failure type,
i.e. can be compared using <code class="literal">=</code>, and is guaranteed to be unique.</p><p>Replace the binding declaration for <code class="literal">Negative-Number</code> with the
following:</p><p><strong>Proper <code class="literal">Negative-Number</code> Failure Type. </strong>
</p><pre class="screen">Negative-Number  &lt;- &amp;(Negative-Number)</pre><p>
</p><p>And now we have a robust way of distinguishing between failures
originating from <code class="literal">to-int</code>, due to the input fields not containing
valid integers, and errors originating from our own application logic.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s06.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s08.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>